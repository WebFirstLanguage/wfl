Perfect. I’ll lay out a detailed engineering plan for implementing the WFL static type checker using full Hindley-Milner type inference, strict type compatibility, and AST annotation. I’ll also decide on a minimal user-defined type model and basic generics to balance complexity and extensibility.

I’ll structure this as a report with sections on type representation, constraint generation and unification, AST traversal, inference rules for all expression and statement types, and a design for type errors. I’ll also recommend practical simplifications to make the checker tractable for a solo dev, while keeping it robust and extensible.

I’ll get started and follow up shortly with a comprehensive breakdown.

# Static Type Checker Design for the WebFirst Language (WFL)

## Introduction and Goals  
WebFirst Language (WFL) is a beginner-friendly, statically-typed language with a natural English-like syntax. To ensure reliability and ease of use, WFL’s compiler will include a **static type checker** that provides **strong compile-time guarantees** without burdening the programmer with explicit types. The type checker will employ **full Hindley–Milner type inference** to deduce types automatically, while enforcing **strict type safety** (no implicit type coercions). The checker will traverse WFL’s Abstract Syntax Tree (AST), inferring types for every expression and **annotating the AST** with these types. This design aims to catch type errors early (at compile-time) and report them in a clear, beginner-friendly manner aligned with WFL’s philosophy. Key goals include:

- **Type Inference**: Automatically deduce the most general type of every expression (using Hindley–Milner), so users rarely need to write types explicitly ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,programmer%20with%20verbose%20type%20declarations)) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=and%20the%20value%20in%20a,have%20to%20declare%20types%20explicitly)).  
- **Strict Type Safety**: Disallow operations on incompatible types – e.g. no mixing Text and Number without explicit conversion ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=result%20is%20a%20number,would%20pop%20up%2C%20guiding%20you)). Every operation’s operands must have matching or expected types, preventing surprises at runtime.  
- **AST Annotation**: Produce a fully typed AST as output of the checker, with each AST node (especially expressions) tagged with its inferred type. This typed AST can be used by later compiler phases (code generation, optimization, etc.).  
- **Extensibility**: The type system is designed to grow with WFL. It initially covers primitives and basic generics (lists, optional “nothing” values, simple user-defined records), but can later extend to advanced features (async results, web element types, etc.) without major redesign.  
- **Beginner-Friendly Errors**: When a type error is found, the checker will produce a **clear, natural-language error message** that explains the problem and how to fix it, following WFL’s Elm-inspired error style ([wfl-error.md](file://file-Cu94WGLkBQAeNjHazU7nKr#:~:text=uses%20text%20where%20a%20number,Amazing%2C%20Informative%2C%20Paternalistic%20Error)).

By meeting these goals, the WFL type checker will ensure programs are **safe and predictable** (preventing common errors like null-reference or wrong-type operations) while keeping the coding experience **intuitive and readable**.

## Type Representation in WFL  
To implement static checking, we need an internal representation of types. We will define a `Type` enumeration (or class hierarchy) that covers all possible WFL types. This representation will support not only WFL’s **primitive types** but also **constructed types** like lists and records, as well as **type variables** for inference. Table 1 outlines the core type variants and their meaning:

**Table 1: WFL Type Variants and Their Meanings**

| **Type Variant**        | **Description**                                                            | **Examples**                       |
| ----------------------- | -------------------------------------------------------------------------- | ---------------------------------- |
| **NumberType**          | Numeric type for integers or floats.                                       | `5` or `3.14` has type **Number**. |
| **TextType**            | Text string type.                                                          | `"Hello"` has type **Text**.       |
| **BoolType**            | Boolean type (truth values).                                               | **yes/no** (or true/false) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=The%20first%20line%20creates%20a,but)). |
| **NothingType** (Bottom)| Special “no value” type. Represents absence (`nothing` literal) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,which%20the)). Can unify with any type (acts as a bottom type). Used for `nothing`/`None` values and for functions that return nothing. |
| **ListType(T)**         | Generic list type with element type **T**. All elements must be of type T ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,you%20use%20a%20block%20syntax)) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=Lists%20in%20WFL%20are%20dynamic,knows%20the%20list%E2%80%99s%20element%20type)). | **List<Text>**, **List<Number>**, etc. |
| **RecordType{…}**       | Struct/record with a fixed set of named fields (each with its own type).   | e.g. **Record** `{ name: Text, age: Number }`. |
| **FuncType(P → R)**     | Function type from parameter types **P** (could be tuple or list of types) to return type **R**. | e.g. an action taking `(Text, Number)` and returning `Bool` has type **(Text, Number) → Bool**. |
| **TypeVar(α)**          | Type variable (unbound type) used during inference for generic or unknown types. These are placeholders that will be unified to concrete types or generalized. |

**Primitive Types:** WFL’s primitives include **Number**, **Text**, **Bool**, and **Nothing**. They are represented as distinct `Type` variants. **Number**, **Text**, and **Bool** are straightforward scalar types. **Nothing** (also called “null” or **none** in other contexts) is treated specially – it denotes the absence of a value and is considered a subtype of all other types (more on this in the optionals section). In the type system, we model `nothing` as **NothingType**, which we treat as a *bottom type* that can unify with any other type ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=language%20treats%20as%20the%20same%29,WFL%20would%20say)). For example, you can assign `nothing` to a Text variable (meaning “no text”) without changing the variable’s declared type ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,which%20the)). Internally, this may be handled by giving `nothing` a fresh type variable that can unify with whatever type context expects.

**Compound Types:** Beyond primitives, WFL supports **compound types** to structure data ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,you%20use%20a%20block%20syntax)). The primary compound types at this stage are lists and records:
- **List<T>:** A homogeneous list of elements of type T. The type checker will maintain the element type as part of the list’s type (e.g. **List<Number>** or “list of number” in WFL’s terms ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,you%20use%20a%20block%20syntax))). This ensures that only matching types can be added to the list. Lists are **parametric/generic**: `List<T>` is a type constructor that takes a type parameter T. An empty list has type `List<α>` with α to be determined by later insertions. (If an empty list is created with no hint of α, the checker might initially assign a placeholder type variable or a special **Any** type and then refine it once elements are added ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,create%20list%20items%3A%20add%201)) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=literal%2C%20if%20supported,1%20add%202%20end%20list)).) Lists in WFL are dynamic in size (you can add/remove elements at runtime) but **type-homogeneous** – all elements must share the same type ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=Lists%20in%20WFL%20are%20dynamic,knows%20the%20list%E2%80%99s%20element%20type)). The type checker enforces this by requiring any `add <item> to <list>` operation to have `<item>`’s type match the list’s element type. If you try to add the wrong type, it’s a compile-time error ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=create%20list%20items%3A%20add%201,would%20be%20a%20type%20error)).
- **Record (Struct):** A record type is a collection of named fields, each with a specified type (similar to a struct or object with a fixed schema). For example, after: 

  ```wfl
  create record person:
      name is "John Smith"
      age is 30
      email is "john@example.com"
      is active is yes
  end record
  ``` 

  The variable `person` has a **RecordType** `{ name: Text, age: Number, email: Text, is active: Bool }` ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=This%20defines%20a%20record%20variable,get)). The type checker represents this as a map of field names to types. WFL leans toward **structural typing** for records: if two record literals have the same field names and types, they are considered the same type (interchangeable) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=Records%20are%20like%20custom%20types,Or%20it%20might%20treat)). This avoids requiring explicit type declarations for records – the structure alone determines the type. The checker must track where a given record type comes from, especially if WFL allows adding/removing fields at runtime. (If a field is removed, one approach is to treat it as setting that field to `nothing` rather than truly altering the type, to keep static typing consistent. We assume that once a record type is inferred, its set of fields is fixed for type-checking purposes, and removing a field is treated as assigning `nothing` to it.) Records give users a way to define simple custom data types on the fly; the type checker ensures that field accesses (`get person’s email`) and updates (`change person email to "new@example.com"`) are consistent with the record’s field types.

**Function Types:** Functions (called **actions** in WFL) have types describing their parameter and return types. If a function takes parameters of types `(T1, T2, ..., Tn)` and returns type `R`, we represent its type as `FuncType([T1,…,Tn] → R)`. For example, an action defined to **“add numbers”** that takes two Numbers and returns a Number would have type `(Number, Number) → Number`. These function types are used when checking calls. WFL’s syntax often includes parameter and return types in the function definition (e.g. `needs X as Text` and `gives back Y as Number`), so the checker knows the intended `FuncType` from the definition. If parameter types are omitted (hypothetically, if WFL allowed that for inference), the checker would assign fresh type variables for each parameter and infer them from usage in the function body and call sites. In the current design, we expect parameter and return types to be explicitly given in the definition (for clarity), so those serve as annotations/direct types for the checker ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=with%20a%20name%20and%20type,If%20no%20parameters%20are)) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=Under%20the%20hood%2C%20each%20action,includes%20the%20type%20of%20each)). The type checker will still infer the types of *local* expressions within the function body.

**Type Variables (Generics):** During type inference, **TypeVar(α)** represents an unknown type that needs to be solved. The checker creates a fresh type variable for constructs whose type is not yet known (for example, the type of a new variable before we examine its initializer, or the element type of an empty list, or the return type of a function during inference). Unification will then determine what concrete type this variable must be. Type variables are also used to represent *generic type parameters*. For instance, the definition of `List<T>` in the type system can be thought of as having a type parameter T that is a placeholder (a type variable) until an actual list type is used in code. The Hindley-Milner algorithm will **generalize** type variables into generic types when appropriate (e.g. a function that doesn’t depend on a specific type might get type `α → α`, meaning it is generic) – we’ll discuss this in the inference section. 

Overall, this `Type` representation is designed to be **extensible**. If later we introduce new kinds of types (for example, an **Async<T>** type for asynchronous results, or a special **Element** type for web DOM elements), we can add new variants to the `Type` enum and update the checker’s rules accordingly. The existing infrastructure for unification and annotation will accommodate new types as long as we define how they unify with others (e.g. unify `Async<T>` with `Async<U>` by unifying `T` with `U`). This way, WFL’s type system can grow without needing a complete overhaul.

## Annotating the AST with Types  
The type checker will operate on the language’s Abstract Syntax Tree (AST), progressively assigning types to each node and then recording those types on the nodes. **AST annotation** means that after type checking, every relevant AST node carries an attribute indicating its inferred type. This makes the AST a *typed AST*, which is useful for downstream compilation stages or for providing hover-type info in an editor.

**Strategy:** We design the AST node structures (for expressions, statements, etc.) to include a field for `Type`. For example, an `ExpressionNode` might have a property `expr_type : Type`. Initially, before type inference, these fields can be set to a placeholder (or left null/unset). The type checker then traverses the AST; whenever it deduces the type of a node, it fills in that node’s `expr_type`. By the end of checking, every expression node will have `expr_type` set to a specific concrete type (no remaining type variables if inference succeeded).

Concretely, the checker will perform a **post-order traversal** of the AST (ensuring we process children before their parent). For each node, it will determine the node’s type based on its form and the types of its sub-expressions, possibly generating constraints (equations) that must hold between types. Once a node’s type is resolved (either directly from a literal or by solving constraints), we attach that `Type` to the node. Some examples:
- A literal node for number `42` is immediately annotated with `NumberType`. A text literal `"hi"` gets `TextType`, and a boolean literal `yes` gets `BoolType`. The literal `nothing` gets a fresh type variable α (or a `NothingType` placeholder) which will later be unified with the expected type context.
- A variable reference node (like using variable `count` somewhere) is annotated with the variable’s type as looked up in the current context/environment.
- An expression like `x plus y` (a binary operation node) will, after inference, have `expr_type = NumberType` (assuming it type-checks) because `plus` produces a Number. The checker will enforce that `x` and `y` themselves have type Number; once that’s confirmed by unification, the `plus` node can be marked as Number.
- A function call node (performing an action) will be annotated with the return type of that function. For instance, `perform add numbers with x as 5 and y as 7` is an AST node representing a call; the checker knows `add numbers` returns Number, so it will annotate this call node as Number type (after verifying the argument types).

**Mutating the AST:** In an implementation sense, we can either (a) mutate the existing AST nodes to fill in type info, or (b) produce a new parallel AST with types. We’ll choose (a) for simplicity: the type checker will directly decorate the existing AST. This requires that our AST node data structures are mutable or designed to accept a type annotation post-creation. We ensure to only finalize a node’s type once all constraints affecting it are resolved (usually after unification).

By annotating the AST, we make error reporting easier too. Each AST node can carry its source code location and now its type; if a type error is detected at a node, we know *where* it occurred (from the location) and *what types* were involved (from the annotations or expected types), which helps in constructing a clear error message pinpointing the issue.

## Constraint Generation for AST Constructs  
The core of the type checker is defining **typing rules** for each kind of AST construct. These rules specify how to generate **type constraints** (equations between types) and requirements when analyzing a piece of the AST. The checker will accumulate constraints and also perform on-the-fly unification to enforce these rules. We describe the rules for each major construct in WFL’s grammar:

### Literals and Constants  
- **Number Literal:** e.g. `42` or `3.14`. Inferred type is **NumberType**. No further constraints – it’s a concrete type. If needed, the literal’s specific numeric kind (int vs float) can be a sub-category, but WFL likely treats both as Number.
- **Text Literal:** e.g. `"hello"`. Inferred type **TextType**.
- **Boolean Literal:** `yes`/`true` or `no`/`false`. Inferred type **BoolType** (WFL uses **yes/no** as synonyms for booleans ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=The%20first%20line%20creates%20a,but))).
- **Nothing Literal:** `nothing` (also can be written as “missing” or “undefined” in WFL syntax ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,which%20the))). This is a special case – `nothing` can fit **any type context** as a way to say “no value” ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=language%20treats%20as%20the%20same%29,WFL%20would%20say)). The checker will assign a fresh type variable (say α) to a `nothing` literal node, and mark it as a “potential Nothing”. Constraints involving this node will unify α with whatever type is required by context. For example, if we have `store name as nothing` and later assign a text to `name`, α will unify with Text, making `name` an Option<Text> effectively. If `nothing` is used in a context that demands a specific type (e.g., passed to a function expecting a Number), the checker will unify α with Number (and likely report a warning or require handling, since using nothing as a Number is allowed but must be checked before use). If a `nothing` literal’s type variable remains unconstrained (e.g., you stored `value as nothing` and never used `value` in a way to give it a concrete type), the checker will **error** or require an explicit type annotation/cast. Essentially, `nothing` introduces an underspecified type that must be resolved or flagged. (We will discuss how `nothing` ties into optional types in a later section).

### Variables, Declarations, and Assignment  
- **Variable Reference:** When an identifier `x` is used in an expression, the checker looks up `x` in the current scope’s **type environment** (a mapping of variable names to their types). The type environment is built as we process declarations. If found, the node’s type is the type from the environment (instantiating generics if needed). If `x` is not declared in the environment, that’s a **compile-time error** for using an undefined variable (reported as “`x` is not defined”). If `x` exists but is declared after this use (in languages allowing forward references), we might either disallow forward use or do a two-pass check; WFL likely requires variables to be declared before use for clarity.
- **Variable Declaration (Initialization):** Syntax: **`store <VarName> as <Expr>`** (or synonym **`create <VarName> as <Expr>`** ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=match%20at%20L99%20VariableDecl%20%3A%3A%3D,%3CExpression%3E))). This either introduces a new variable or updates an existing one. The type rule: infer the type of `<Expr>` (call it T). Then bind `<VarName>` in the environment with type T. The AST node for the variable declaration can itself be considered to have type **NoneType** or a Unit (since the declaration statement doesn’t produce a value to use in expressions). However, we *do* annotate the variable’s definition site with the inferred type of the initializer for clarity. For example, `store count as 42` infers the literal `42` as Number, then assigns `count: Number` in the environment ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=and%20the%20value%20in%20a,have%20to%20declare%20types%20explicitly)). From that point on, any use of `count` is type-checked as Number. If a variable is declared with `nothing` (e.g. `store result as nothing`), then as mentioned, we assign a type variable α to `result`. We don’t yet know result’s concrete type, so `result` is effectively of type α (which could be unified later). We might mark `result` as “maybe-nothing of some type” internally. The user can later assign a concrete value, or if they try to use `result` without assigning a real value, the checker will raise an error (“`result` might be nothing (unset)”). **Generalization:** In Hindley-Milner, a let-binding (which a `store` is similar to) would normally generalize type variables in the bound expression that are not tied to the outside. For example, if WFL allowed a polymorphic function definition like `store identity as (define action that returns input as same type)`, we could infer a type like α→α for it and generalize to ∀α. In practice, WFL variables are likely not defined polymorphically in local scope, so we may **only generalize at top-level or for function definitions**, not for every `store`. Thus, a `store` statement yields a monomorphic binding of the inferred type (which can be a compound type or generic type like List<Number>, but not a type scheme with unbound parameters).
- **Variable Assignment (Re-assignment):** WFL might allow updating an existing variable’s value with new data (perhaps with syntax like **`change X to Y`** or simply reusing `store` if allowed for updates). The rule: the variable `X` must already have a type in the environment (from a prior declaration). We infer the type of the new expression `Y`, say it is type U. Then we unify U with the existing type of `X` (call that T). If `T` and `U` do not unify (e.g. `T` is Number and `U` is Text), it’s a type error: you cannot assign a value of a different type to `X`. For example, if `age` was inferred as Number, later doing `change age to "thirty"` (Text) would raise an error (“Expected a number for `age` but found text”) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,make%20a%20boolean)). One subtlety: what if the existing value of `X` was `nothing` (meaning `X`’s type is currently unknown α)? Then unifying α with U will set `X`’s type to U (effectively deciding the type now). Conversely, if `X` had a concrete type but we now assign `nothing` to it, as discussed, we allow `nothing` to unify with `X`’s type T (meaning `X` retains type T, but now holds a `nothing` value – we handle the “maybe nothing” in flow analysis). In summary, re-assignment does **not change a variable’s type**; it must always be a value of the same type T (except using `nothing` as a special case which doesn’t change T but introduces a potential null).

### Binary Operations and Expressions  
WFL uses English words (and some optional symbols) for operators ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,less%20intimidating%20and%20more%20approachable)). The type checker must enforce the operand types for each operator and determine the result type:
- **Arithmetic Operators:** e.g. **`plus`** (or `+`), **`minus`**, **`times`**, **`divided by`**. These likely apply to Numbers only. The rule for `A plus B`: infer type of A (call it TA) and type of B (TB); constrain TA = Number and TB = Number, because addition is defined for numbers. If A or B is not a Number, unify will fail and we report a type error. The result of `A plus B` is type **Number**. Similar for `minus`, `times`, etc. If WFL eventually allowed operator overloading (e.g. `plus` for text concatenation), we’d handle that via either overloading rules or distinct keywords. In the current design, **no implicit coercion** is done between Text and Number ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=result%20is%20a%20number,would%20pop%20up%2C%20guiding%20you)): adding a Number and a Text is *not* allowed (unless explicitly converted). So `5 plus "5"` would yield a compile error. The error message would say something like “You tried to add a Text to a Number, which isn’t allowed. Perhaps convert the text `"5"` to a number, or the number 5 to text, depending on intent.”
- **String Concatenation:** WFL uses the word **`with`** or **`and`** to concatenate Text (e.g. `"Hello" with name`) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=and%20,more%20on%20this)). The rule for `Expr1 with Expr2`: both sub-expressions must be **Text**. So constrain type(Expr1) = Text and type(Expr2) = Text. Result type is Text. If one side is not Text, we have a mismatch. The language design hints that they *could* auto-convert a number to text in this scenario (e.g. `text1 with 5` might turn 5 into `"5"`), but given the emphasis on safety, the chosen approach is to **require an explicit conversion**. So the checker will treat `Text with Number` as a type error, and the error message will specifically suggest a fix: *“Expected text but found number – try converting it first”*. The user can then write `5 as text` to explicitly cast, which the type checker would handle as a conversion function (i.e. `as text` could be treated as a built-in operation that takes a Number and returns a Text, which is type-checked accordingly).
- **Comparison Operators:** e.g. **`is equal to`** / **`equals`**, **`is greater than`**, **`is less than`**, etc. These produce Boolean results. For equality, a rule of thumb is that the two operands must be of the **same type** (you can only compare like types for equality). So for `A is B` (if used as a comparison): we generate constraint type(A) = type(B) (they must unify to one type), and the result type of the `is` comparison is **Bool**. If A is Number and B is Number, fine (Bool result); if A is Text and B is Text, fine; if A is Number and B is Text, the constraint fails – we would error “Cannot compare a Number and a Text for equality”. For ordered comparisons (`greater than`, `less than`), these likely only make sense for Number (and maybe for Text alphabetically, but probably not in a beginner language unless specified). We will enforce both sides are Number for `greater than/less than`, and result is Bool.
- **Logical Operators:** e.g. **`and`**/**`or`** for booleans (assuming WFL has “and” as logical AND when used in a boolean context). If `cond1 and cond2` is a boolean expression, we require cond1: Bool, cond2: Bool; result Bool. (WFL’s use of “and” is contextual – in a condition it’s a logical operator, in a concatenation context it might be string join. The parser will differentiate these by context, and the type checker will confirm consistency).
- **Other Expressions:** WFL might have additional expression forms (such as **`perform action`** calls, discussed separately, or possibly **ternary expressions** like `if ... else ...` as an expression). We cover function calls below and conditionals in the next section. Another possible expression form is **type conversion** syntax `(<Expr> as <TypeName>)`, which WFL hints at (e.g. `5 as text` for conversion). If present, the rule for a cast `E as T` is: infer type(E) = TE. Check that a conversion from TE to target type T is allowed (either built-in or user-defined conversion). If allowed, the result type is T. Essentially, we treat this as a function call to a conversion function in the type system: e.g. a built-in function conv: TE → T must exist. We’ll incorporate known conversions: Number→Text (to string), Text→Number (if numeric text), etc. Conversions between unrelated types are not allowed (or will be a compile error if attempted).

### Control Flow: Conditionals and Branches  
- **If / Else Statement:** In WFL, an `if` is written in natural language style, e.g. **`if user is active then display "Online"`** ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,be%20read%20almost%20like%20prose)). This suggests an `if` statement with an optional `else`. The type rule: The condition expression must have type **Bool**. We enforce that by checking the condition (e.g. `user is active` likely translates to a boolean expression, or if `user` is Bool directly, then `if user then ...`). If the condition is not boolean, it’s a type error (“Expected a yes/no condition but found a different type”). For the branches: since WFL’s `if` is primarily a statement, each branch is a block of statements. The branches themselves don’t produce a value that propagates (unlike a ternary expression in some languages). So we don’t need to unify branch result types unless WFL allows expressions like `x = if ... else ...`. In case WFL *did* allow `if` as an expression (not likely given the syntax, but let’s consider completeness), then we would require that the type of the last expression in the `then` block unifies with the type of the last expression in the `else` block, and that unified type would be the type of the whole `if` expression. If they differ (say one branch yields a Number and the other yields a Text), we’d error: “Incompatible branch types: then-branch is Number, else-branch is Text. Both branches of an `if` must produce the same type.” This is a standard rule in expression-oriented languages. For WFL’s likely statement-oriented `if`, we simply type-check each branch in isolation under the assumption the condition is bool. We also allow an `else` or possibly multiple `else if` (WFL might use an `otherwise` keyword for else ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=and%20,more%20on%20this))). Each condition in a chain must be Bool as well.
  
  Additionally, WFL’s design hints at **flow-sensitive typing**: for example, within the `if` branch after checking `if value is nothing`, WFL considers `value` as “nothing” in that branch, and in the `else` (the `otherwise`) branch, `value` can be treated as definitely not nothing (its actual type) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=check%20if%20value%20is%20nothing%3A,value%20is%20definitely%20not%20nothing)) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=literal%20,type%2C%20or%20require%20a%20cast)). To support this, the type checker can perform a **branch refinement**: when the condition is a type check (like `x is nothing` or potentially `x is <SomeType>` in future), the checker can refine the type of `x` in the true and false branches. In the true branch of `if x is nothing`, we treat `x` as type **NothingType** (or more precisely, the branch is only taken when x has no value). In the false branch (`otherwise`), we can treat `x` as its non-None type (e.g. if x was Option<Number>, in else it’s Number). This requires the type checker to carry **boolean constraints**: e.g. condition “x is nothing” imposes that in the true branch, x: Nothing, in else branch, x: T (unwrapped). This is a form of **union/optional type narrowing**. We’ll implement this by tagging variables that are optional; a check `is nothing` will produce new environments for each branch where the variable’s type is adjusted. This ensures safe use: within the else branch, you can use `x` as a definite value without error, whereas in the true branch you’d likely not use x (or if you do, it’s known to be nothing).

- **Match/When Expression:** The problem description didn’t explicitly ask for pattern matching, but WFL’s docs mention a `when/otherwise` construct for error handling and possibly pattern matching on types in future ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=In%20the%20otherwise%20branch%2C%20,matching%20hint%20in%20guiding%20principles)) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=check%20if%20value%20is%20nothing%3A,value%20is%20definitely%20not%20nothing)). If WFL introduces a `when ... is ...` multi-branch (like a switch or pattern match), the type checker would ensure each branch’s condition is checking the same variable or expression against different values/types, and that either all branches produce the same type (if it’s an expression) or are valid as statements. Also, if it’s an exhaustive match on an enum, the checker would ensure all variants are handled or an `otherwise` is present. Since pattern matching is an advanced feature, we’ll not detail it fully here, but note that the type system can accommodate **union types** or **enums** by treating them similar to variant records or tagged unions, and checking patterns narrows the union to a specific variant in each branch.

- **Loops:** WFL has natural-language loops like **count loops** and **for-each loops** ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=Loops%20Loops%20in%20WFL%20allow,structure%20with%20an%20explicit%20end)) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,end%20list)). These are statements, not expressions (they don’t produce a value, they just execute repeatedly). For a **count loop** (e.g. `count from 1 to 5:`), the type rules are: the start and end expressions must be Numbers (since it’s a numeric range). An optional `by <step>` must also be Number if present. The loop introduces an iteration variable (by default named `count`) which the spec says is a Number that takes each value in the range ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=effectively%20counts%201%2C%202%2C%203%2C,inside%20the%20loop%20if%20needed)). The type checker will create a new scope for the loop body with `count: Number` in the environment. The body is then type-checked normally with that assumption. (The name `count` could shadow an outer variable safely for the loop’s scope if needed.) After the loop, that loop variable goes out of scope. A **for-each loop** like `for each item in <collection>:` requires that the collection expression has an **iterable type**. Likely WFL supports iterating over **List<T>** and **Set<T>**. So the collection expression must have a type of the form `List<X>` or `Set<X>` (or perhaps any type that is “collection of X”). The checker will unify the collection’s type with `List<α>` or `Set<α>` to find the element type α. Then it introduces a loop variable (e.g. `item`) with type α inside the loop body ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=Lists%20in%20WFL%20are%20dynamic,knows%20the%20list%E2%80%99s%20element%20type)). The loop body is checked under that environment. Any attempt to modify the collection’s structure (like removing elements) should still maintain type α for its elements, which the checker will enforce (e.g. you can only add items of type α to the collection inside the loop or elsewhere). Since loops don’t yield a value, they can be considered to have type None/Unit for the purpose of AST annotation (or simply we mark them as statements only). 

### Function (Action) Definitions and Calls  
Functions (called **actions** in WFL’s terminology) are defined with a signature and a block. The type checker needs to handle both the **definition** and **call** sites:

- **Function Definition:** For example, WFL might have syntax: 
  ```wfl
  define action add numbers  
      needs: x as number  
             y as number  
      gives back: sum as number  
      do:  
          store sum as x plus y  
  end action
  ``` 
  This defines an action `add numbers` that takes two numbers (`x` and `y`) and returns a number (`sum`) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=with%20a%20name%20and%20type,If%20no%20parameters%20are)) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=provide%20a%20name%20and%20type,you%20omit%20this%20section)). The type checker will process this definition in several steps:
  1. **Enter New Scope:** Each action definition introduces a new scope for its parameters and local variables (the function body).
  2. **Parameters:** The `needs:` section provides parameter names and types. The checker adds each parameter to the function’s environment with the specified type. In the above example, `x: Number`, `y: Number`. If a parameter’s type were not explicitly given, we would create a type variable for it and attempt to infer from usage, but given WFL’s design, the type is always stated in the `needs:` clause (which is part of the readable syntax).
  3. **Return Type:** If a `gives back:` section is present, it defines the return value’s name and type. E.g. `sum as number` means the function should return a Number. The checker will add a symbol `sum: Number` in the function body environment **if** the language treats the return name as a variable to assign. (WFL appears to do that – the return “name” can be used in the body to accumulate the result ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=provide%20a%20name%20and%20type,you%20omit%20this%20section)) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=match%20at%20L509%20store%20result,%2F%2F%20displays%2012)).) If the action doesn’t return anything (no `gives back:`), we treat the function’s return type as **NothingType** (or a special Unit type), meaning it’s used only for its side effects.
  4. **Type of the Function:** Based on the needs and gives back, we can establish the function’s type signature upfront: here, `add numbers` has type `(Number, Number) → Number`. We will record this in a global environment of function types (so that call sites can be checked against it). If the function had type variables in its signature (e.g. a generic function, not common in WFL’s current syntax), we would treat it similarly but allow generalization.
  5. **Check Body:** We then type-check the function’s body (the `do: ... end action` block) using the environment that includes parameters and (optionally) the return variable. Inside, standard rules apply for each statement. Notably, we must ensure that the code assigns a value to the return variable (if one is expected) along all paths. For example, if an action has `gives back: result as text`, then by the end of the action, `result` should have been set to some Text in every possible execution path. Otherwise, there’s a path where the function would not produce a result – the checker should flag that as an error (“`result` not set in all paths”, analogous to “missing return” errors).
  6. **Implicit Return:** In some languages, the last expression’s value is the return value. WFL seems to use an explicit return variable instead. So we don’t have a `return <expr>` statement; instead you “store something in the return variable”. The type checker can enforce that *only one of these approaches is used* – either ensure the designated return variable is used, or if an explicit `return` keyword were introduced, handle that. In our design, since `gives back: name as Type` is provided, we’ll stick to using that name as the place where the return value lives.
  7. **Generalization:** After type-checking the body, we consider if the function can be polymorphic. In classic HM, if the function’s implementation does not pin down some type variables, we’d generalize them. However, because WFL requires explicit parameter types, we won’t suddenly generalize unknown types – any type variables arising would likely indicate a logic error (or an unused generic). We will mostly end up with a monomorphic function type (or parametric only in the sense of those generic types explicitly in the signature). If WFL in the future wants generic actions (e.g. an action that works on a “list of T” without specifying T upfront), then we’d allow type variables in the signature and generalize them, effectively giving the action a polymorphic type schema (∀T. List<T> → Number, as an example).

- **Function Call:** WFL calls actions with a `perform` syntax or similar, e.g. **`perform add numbers with x as 5 and y as 7`** ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=match%20at%20L509%20store%20result,%2F%2F%20displays%2012)). The type checker steps:
  1. Identify the action being called (here `add numbers`), look up its type signature from the environment of defined actions. Suppose we have `add numbers : (Number, Number) → Number`.
  2. Check the arguments given. WFL uses named arguments (`with x as 5 and y as 7`) rather than positional, which is helpful for clarity. The checker will match the names `x` and `y` to the function’s parameters. This way, even if the user swaps the order, the correct matching is done by name. We verify that all required parameters are provided exactly once, and no unknown parameter names are given.
  3. For each argument expression, infer its type and then unify it with the expected type from the function signature. Here, `5` is inferred as Number, and the parameter `x` expects Number – it matches. If instead the code was `perform add numbers with x as "5" and y as 7`, then `x` has type Text (from `"5"`) but expected Number, so unification fails. The checker would error: “Parameter `x` expects a number, but you provided text”. The error can point to the argument name to be extra clear.
  4. If all arguments type-check against the parameters, then the call is valid. The call expression’s type is the function’s return type. So `perform add numbers with x as 5, y as 7` gets type Number (meaning it produces a Number result). If the action’s return type is Nothing (i.e. a procedure with no return), then the call expression actually should not be used in an expression context. WFL syntax indicates that if an action returns nothing, you simply `perform` it as a standalone statement ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=match%20at%20L529%20If%20an,it%20on%20its%20own%20line)). If someone tried to `store result as perform someVoidAction`, the checker knows `someVoidAction` returns nothing and would raise a type error like “`someVoidAction` does not return a value, so it can’t be used here”. 
  5. **Instantiation:** If the function’s type was polymorphic (had type variables), each call must instantiate those to concrete types. For example, imagine a hypothetical action `define action identity needs: input as T gives back: output as T`. If WFL allowed that, its type would be ∀α. α → α. When checking a call `perform identity with input as 5`, we instantiate α = Number for this call and expect a Number back. If later `perform identity with input as "hi"`, instantiate α = Text. Our checker would handle this by cloning the type scheme with fresh type vars per call. (This is standard for HM polymorphism: instantiate at use sites). However, since WFL doesn’t yet emphasize user-defined generics in actions, we likely won’t implement full polymorphic instantiation beyond built-in generics like list. Built-in polymorphic functions (like maybe a library function that works on any list) can still be handled similarly.

In summary, the type checker treats function calls by ensuring the call’s argument types match the function’s parameter types, and by assigning the call node the proper return type. Any mismatch (wrong number of args, wrong types, unknown function name) is a type error. These rules guarantee that if the program compiles, no function will ever be called with the wrong types at runtime – a key safety feature.

## Hindley–Milner Inference Algorithm  
The rules above describe the *what* of type-checking. The *how* is accomplished via the Hindley–Milner (HM) type inference algorithm, a classical algorithm that can deduce types automatically for languages with polymorphism. We will implement a variant of the **Algorithm W** (a well-known formulation of HM inference) tailored to WFL’s language features. The algorithm operates in two interwoven phases: **constraint generation** (or typing rule application) and **unification** (solving those constraints). Here’s an outline of the process:

**1. Environment and Type Variables:** The checker maintains a **type environment** (Γ) mapping identifiers (variables and function names) to their types or type schemes. It also has a mechanism to create fresh type variables (for unknown types) – typically a counter to generate new α₁, α₂, etc. Initially, Γ will have predefined types for built-in functions or constants (e.g., we know the type of `print` function if any, or we might predefine `nothing` as ∀α. α to allow it to unify with anything). As we traverse the AST, when we encounter a new variable declaration, we extend Γ.

**2. Constraint Generation (Typing Rules):** As the checker visits each AST node, it applies the rules from the previous section to generate type constraints and decisions:
   - If the node is a literal or a known value, assign its type immediately.
   - If it’s an expression node with subexpressions, generate constraints relating subexpressions’ types. For example, for binary op node `A plus B`, generate (type(A) = Number) and (type(B) = Number) and (type(node) = Number).
   - If it’s a variable reference, get type from Γ.
   - If it’s an assignment, generate constraint (type(rhs) = type(lhs_var)).
   - If it’s an `if` node, ensure (type(cond) = Bool), and then check branches as needed.
   - … and so on for each construct.

   The checker can accumulate these constraints in a list or, more directly, unify types on the fly. Many implementations do on-the-fly unification: as soon as you know two types must match, you unify them immediately rather than storing an equation for later. We’ll likely follow this immediate unification approach to simplify logic (less need to store large constraint sets).

**3. Unification Algorithm:** **Unification** is the process of solving type equations and finding a consistent assignment for all type variables. We implement a function `unify(type1, type2)` that attempts to make `type1` and `type2` the same:
   - If both types are already the same concrete type (e.g. Number vs Number), unify succeeds trivially.
   - If one is a type variable α and the other is some type T, we need to bind α := T *provided* that T does not (directly or indirectly) contain α (occurs-check). This check prevents infinite types. For example, unifying α with List<α> should fail because it implies an infinite type α = List<List<List...>>.
   - If both are type variables (α, β), we can bind one to the other (essentially they become the same unknown type).
   - If both are constructed types, e.g. List<T1> and List<T2>, then we unify their inner type parameters (unify T1 with T2). Similarly, for function types, unify (P1→R1) with (P2→R2) by unifying the parameter lists P1 vs P2 (each param pair) and the returns R1 vs R2.
   - If the two types are different constructors (e.g. Number vs Text, or List<Number> vs Record{…}), unify fails – these types can never match.
   - If one or both types are still type variables with substitutions already in place, we first **find their current representative** (using union-find or a substitution map). For example, if earlier we unified α to Number, and now we see a need to unify α with some other type, we substitute Number for α and proceed.

   We maintain a **substitution map** (or union-find structure) that tracks bindings of type variables to types. Each time we unify α with some type, we record that substitution. Then any future occurrence of α will be considered as that type. We also propagate substitutions deeply: e.g. if we substitute α = Number and we had a constraint that β = List<α>, after substitution that becomes β = List<Number>.

   If unification finds a conflict, it returns an error. For instance, if we attempt to unify Number with Text, that’s a conflict (they are distinct base types). Or unify `Record{name:Text}` with `Record{name:Number}` would conflict on the field type. Or if an occurs-check fails (trying to unify α with a type containing α), that’s also an error (which conceptually would mean a recursive type requirement).

   Hindley–Milner’s completeness ensures that if a typing solution exists, unification will find the most general one (most generalized types for type variables). It **infers the principal type** for each expression automatically ([Differences between TypeScript and Elm - DEV Community](https://dev.to/lucamug/typescript-and-elm-3g38#:~:text=,any)). For example, if we have a function that simply returns whichever of two parameters is longer (choosing by some operation that works for any “sequence”), HM might infer a polymorphic type. In WFL’s simpler uses, principal type might often be just the concrete type (since many things are monomorphic).

**4. Let-Polymorphism (Generalization/Instantiation):** One of HM’s key features is **generalization at let**. In WFL, the analogous points are variable declarations and function definitions. After inferring the type of a let-bound expression, HM will generalize any type variables not connected to the outside environment to make the binding polymorphic. For example, in ML: `let id = fun x -> x in ...` results in `id : ∀α. α→α`. In WFL, as discussed, local variables likely won’t be polymorphic. However, consider top-level definitions (like a utility action that could work on any type list). If we had such a case and the implementation does not pin down the type, we could generalize. Our checker will handle generalization as follows:
   - When we exit a **function definition**, we will generalize the function’s type if it contains type variables that are not fixed. Typically, because parameters and return were explicit, this won’t happen unless those were type variables to begin with (meaning the function was declared generic). In that case, we mark the function’s type as a **type scheme** ∀α, … (some variables) . Type.
   - When we finish a **top-level variable declaration** (if WFL allows a `store` at top level – e.g. define a constant or a polymorphic lambda), we would generalize it similarly. But if it’s just a constant of a concrete type, no need.
   - **Instantiation**: Whenever we later use a polymorphic binding (calling a polymorphic action, or referencing a polymorphic constant), we instantiate fresh type variables for its generalized type. This avoids variable collision and ensures each use can have its own type. Instantiation is essentially cloning the type with new TypeVar for each universally quantified type variable.

   This mechanism ensures that we can reuse one definition in many type contexts without writing separate versions. Again, WFL might not heavily expose this to the user, but internally, it allows things like the list operations or perhaps a generic library function to be type-safe for any type.

**5. Putting it Together (Algorithm Walkthrough):** To illustrate, consider a simplified example in WFL:

```wfl
store a as 5           // a : Number
store b as "Hello"     // b : Text
store c as a plus 1    // c : Number (a plus 1, a is Number, 1 is Number)
store a as b           // ERROR: assigning Text to a Number
```

The checker process:
   - Initialize env = {}.
   - `store a as 5`: infer `5 : Number`. Generalize (no free vars to generalize). Bind `a: Number` in env.
   - `store b as "Hello"`: `"Hello": Text`. Bind `b: Text` in env.
   - `store c as (a plus 1)`: 
       * infer subexpr `a`: look up env, `a: Number`. 
       * infer subexpr `1`: Number.
       * For `plus`: enforce both operands Number (they are). Result = Number.
       * So `c : Number`. Bind `c: Number` in env.
   - `store a as b`: 
       * `a` in env as Number.
       * infer `b`: env says Text.
       * unify Number = Text -> fails. 
       * Report error: *“Type Mismatch: `a` is a number but you’re trying to assign text to it. Text and Number cannot be used interchangeably.”*.

For a more complex scenario with a function:

```wfl
define action greet 
    needs: name as text 
    gives back: message as text 
    do:
        store message as "Hello, " with name
end action

store msg as perform greet with name as "Alice"
store n as perform add numbers with x as 5 and y as "7"
```

- When defining `greet`, we set up env for the function: `{ name: Text, message: Text }` (from signature). In body: `"Hello, " with name` requires both parts Text (which they are: literal is Text, name is Text) and yields Text. So `message = Text`. Good. The action’s return type was declared Text, and indeed we assigned a Text to `message`. No free type vars, so greet’s type is fixed as (Text → Text).
- We record `greet: Text → Text` in the global env for actions.
- For `perform greet with name as "Alice"`: `"Alice": Text` unifies with parameter `name: Text`. Ok. The call’s type = Text (the return). So `msg: Text`.
- For `perform add numbers with x as 5 and y as "7"`: We assume `add numbers: (Number, Number) → Number` (as defined earlier). Here `x as 5` (Number ok) and `y as "7"` (Text) – unification for `y` fails because expecting Number, got Text. The checker errors: *“The action `add numbers` expected a number for parameter `y`, but it got a text. (Perhaps you wrote `"7"` instead of 7 without quotes?)”*. The first part of that message comes from the type system; the parenthetical hint is something we can add in documentation to help the beginner see the issue (since providing `"7"` likely was a mistake of quoting a number).

This process is largely automated – the programmer didn’t annotate types for `a, b, c, msg, n` explicitly, but the checker inferred them all and caught the mistakes. Hindley–Milner guarantees that if there is a consistent typing, the algorithm will find it, and it will find the *most general* typing that satisfies all constraints (which ensures maximal reusability of code) ([Differences between TypeScript and Elm - DEV Community](https://dev.to/lucamug/typescript-and-elm-3g38#:~:text=,any)).

**Type Variable Management:** An important implementation detail is managing the lifecycle of type variables. We will:
   - Generate a fresh TypeVar each time we encounter an expression that needs an unknown type. This includes each function parameter (if not annotated), each new variable with `nothing` or empty list, etc.
   - Use a union-find structure or a substitution map for unification. For example, we might keep a dictionary mapping a TypeVar ID to a Type (which could be another TypeVar or a concrete type) representing the current known substitution. Initially, each TypeVar maps to itself (or nothing). When unifying, say, α with Number, we update map[α] = Number. When unifying two TypeVars, we union them (point one to the other).
   - Perform **occurs-check** when unifying to avoid infinite loops: ensure that if we are binding α = some type T, α is not itself part of T’s definition (we can implement this by a recursive scan or by maintaining structure ranks).
   - After inference, apply the final substitution to all type variables in the AST annotations so that each node’s type is fully resolved (no raw TypeVar remains). Any TypeVars that remain un-substituted indicate a type could not be determined (should not happen in valid programs; if it does, it might mean the program has an ambiguity that needs a hint, or an unconstrained value like an unused `nothing` – which we treat as error).
   - Handle **scoping**: When leaving a scope (like finishing type-checking a function body), we will remove local variables from the environment and also determine if any type variables in the function’s type should be generalized (as described). We must be careful that we don’t accidentally carry a local type variable outside its scope.

The Hindley–Milner algorithm has a well-known property of soundness and completeness for the class of languages it handles ([Hindley–Milner type system - Wikipedia](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#:~:text=,3%20Context%20and%20typing)). In WFL, we are extending it with a few extras (the `nothing` concept, record types, etc.), but these are all within a realm that HM can be adapted to (with perhaps some adjustments like limited union types for optionals). The result is that the type checker can **deduce types for all expressions** and ensure the program is **well-typed** or otherwise pinpoint exactly where a type mismatch occurs.

## Handling `None`/`Nothing` and Optional Types  
Dealing with the absence of a value (null/none) is notoriously a source of bugs in programming. WFL addresses this by providing a `nothing` literal (and synonyms “missing” or “undefined”) to represent “no value,” but encouraging safer patterns like option types ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=match%20at%20L1101%20something%20like,is%20nothing%E2%80%9D%20in%20a%20condition)). The type checker will implement a strategy that balances convenience (allowing `nothing` where needed) with safety (forcing the programmer to handle the `nothing` case explicitly).

**`nothing` as Bottom Type:** As noted, we conceptually treat `nothing` (None) as a **bottom type** that can unify with any type ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=language%20treats%20as%20the%20same%29,WFL%20would%20say)). In practical terms, when the checker sees a `nothing` literal, it creates a fresh type variable α and perhaps tags it with a flag “isNothing=true”. This α can unify with anything, meaning if we later see constraints α = T (for some concrete T), we allow it and essentially decide that “this `nothing` is being used as a placeholder for a T”. For example:
```wfl
store username as nothing   // username: α (unknown, nothing)
...
store username as "guest"   // "guest": Text, unify α = Text -> α becomes Text
```
After the second line, `username`’s type is resolved to Text. Until that happened, `username` was of an indeterminate type. If `username` had been used in between without assignment, that would be problematic – the checker would at least warn “username might be nothing here”.

**Option Type Approach:** Another way to view `nothing` is as an **Option type**. In many statically-typed languages (e.g. Haskell’s `Maybe`, Swift’s `Optional`), a variable that might be null is given a union type like “either T or None”. We can model that internally: whenever a type variable α originates from a `nothing`, we could treat the type as `Option(α')` (with α' another type var for the eventual real type). But since WFL doesn’t have an explicit syntax for `Option`, we might not expose this formally. Instead, we implement the same checks that an Option type would require:
  - If a variable was never assigned a non-nothing value, using it where a concrete value is needed is an error.
  - If a variable *could* be nothing at runtime, the compiler should force a check or provide a default before using it.

**Flow-sensitive “Nullable” Checking:** We will incorporate a limited form of **null safety** akin to languages like Kotlin or TypeScript’s strict null checking. Here’s how:
  - If a variable’s type is currently undetermined due to being set to `nothing` (like α from above), and later it’s used in a context requiring a concrete type, the checker will error unless by that point α got unified to some type. For instance:
    ```wfl
    store x as nothing
    display x
    ```
    At the `display x`, what is x’s type? It’s still α with no constraints. We can’t display “unknown”. The checker would report: “`x` has no value here (it’s nothing), so it can’t be used. Initialize `x` before using it or check if it’s nothing.”
  - If a variable has a known type T but was at some point set to nothing (meaning it’s *nullable* in effect), we can track a boolean “nullable” attribute for that variable’s type. For example:
    ```wfl
    store total as 0        // total: Number (not null yet)
    ...
    store total as nothing  // now total is a Number that could be nothing
    ...
    if total is nothing:
        // handle missing total
    otherwise:
        display (total plus 5)   // safe: in this branch total is definitely a Number
    ```
    When `store total as nothing` happens, we unify nothing’s type var with total’s type (Number). That unification itself doesn’t fail – it basically says total can be “Number or nothing”. We mark `total` as possibly nothing. Now, whenever `total` is accessed, the checker will enforce that you account for the nothing possibility. In the example, we do an `if total is nothing`. In the `otherwise` branch, the checker refines `total`’s type from “Number (maybe null)” to “Number (definitely not null)” ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=check%20if%20value%20is%20nothing%3A,value%20is%20definitely%20not%20nothing)). Thus `total plus 5` type-checks as Number plus Number. If we had not checked and directly did `total plus 5` after `total` could be nothing, the checker would raise an error like: *“`total` might be nothing here, but a number is required for addition. Check that `total` is set before using it.”*. This is analogous to how optionals must be unwrapped.
  - Implementation-wise, we can implement the “nullable” tracking by decorating the type in the environment. E.g., after assigning nothing to a Number, we could treat `total`’s type as still Number but with a flag (or treat it as `Option<Number>` internally). The condition `is nothing` then acts to assert whether the Option is None or Some. We can encode that logic by having a special case in constraints: a check `if X is nothing` doesn’t directly unify types, but instead it triggers a split analysis: in the true branch, we know X’s value is the `Nothing` variant; in the false branch, X can be treated as type T non-null. This goes a bit beyond pure HM (which doesn’t do flow analysis), but it’s a pragmatic extension for a safer language. It doesn’t break inference; it’s more of an *additional semantic check* layered on top.
  - The type error for using a maybe-nothing where a concrete is needed is essentially: *“Expected a **`<Type>`** but found nothing.”* WFL’s documentation explicitly mentions this scenario: *“using nothing where a concrete value is required might trigger an error that should be handled (WFL would say something like “Expected a X but found nothing”)”* ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=language%20treats%20as%20the%20same%29,WFL%20would%20say)). So we will indeed implement that error message.

**Optional Types & Future:** The design allows for an explicit **Option<T>** type in the future if desired. For example, WFL could introduce a way to declare a variable as optional: `maybe Text` or so. Internally, we’re already handling it similarly, just implicitly. We also allow the possibility of providing **default values** to avoid nothing: WFL might encourage patterns like:
```wfl
if name is nothing:
    store name as "Anonymous"
```
or a hypothetical expression `value or defaultValue`. The type checker would ensure that after such handling, you can use the value safely.

In summary, the type checker treats `nothing` as a polymorphic null that unifies with any type, but it imposes *extra checks*: any code path that uses a possibly-nothing value must prove (via a condition or prior assignment) that it’s not nothing. This prevents the classic “null reference error” at runtime – the compiler will catch it. This approach is informed by languages like Elm (which eliminate null by using Maybe type) and TypeScript/Rust (which require checks for undefined/None). WFL thus provides the convenience of `nothing` for uninitialized or empty values, but via the type checker it ensures those cases are handled explicitly rather than causing unpredictable errors later.

## Generics and Parametric Types (Lists and Beyond)  
WFL’s type system includes generics primarily through its collection types. We’ve already discussed **List<T>** as a parametric type. Let’s elaborate on how the checker handles generics and the decision between parametric vs opaque types:

**Homogeneous Lists (Parametric):** WFL lists are homogeneous – all elements of the list share one element type ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=Lists%20in%20WFL%20are%20dynamic,knows%20the%20list%E2%80%99s%20element%20type)). This is naturally modeled by a type constructor with a type parameter, `List<T>`. The type checker treats `List` as a built-in generic: when you create or manipulate a list, the element type is a type variable until constrained by usage. For example:
```wfl
create list items:
    add 1
    add 2
end list
```
When encountering `create list items: ... end list`, the checker will:
  - Create a fresh type variable α for the element type of `items` (items : List<α>).
  - Process each `add` inside. `add 1` tells us 1 is Number, so it constrains α = Number. After that, α becomes Number. Then `add 2` is consistent (Number again, matches α which is now Number). So items : List<Number> ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=lines.%20For%20instance%2C%20after%3A%20,later%2C%20it%20would%20be%20a)).
  - Annotate `items` with type List<Number> in the environment.
  - If later someone does `add "hello" to items`, the checker sees items is List<Number> and "hello" is Text, so it unifies Text = Number which fails. Error: *“Cannot add a text to a list of number”*. That is caught at compile time, as intended ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,would%20be%20a%20type%20error)).
  - If a list is created empty (`create list emptylist: end list` with no adds), then α remains unconstrained. The checker could either:
    - Require an explicit type annotation (not currently in syntax, but maybe `create list of number: end list` could have been an idea).
    - Or treat it as `List<Any>` internally until something is added. “Any” could be a special top type that allows any element, but that undermines type safety unless restricted to that list. Alternatively, we infer it as List<α> and if α is never resolved, the list is basically never used in a typed context (which might be okay). We might warn in such a case that the element type couldn’t be inferred.
  
The parametric list approach ensures **type consistency** and lets the compiler optimize and check element operations strongly. If instead WFL had chosen an **opaque list** (like a list of variants), we would declare just `List` without a type parameter, and allow mixed types. But then any operation retrieving from the list would produce an ambiguous type (maybe an `Any` type that the user must downcast). That would compromise WFL’s goal of strong guarantees, so we avoid the opaque approach. By using generics, **all element insertions and accesses are checked**. For instance, if WFL has an operation `get first element of <list>`, and we know the list is List<Text>, then that operation returns a Text type. If someone tried to assign that to a Number, we error.

**Other Generic Types:** WFL also has **Set<T>** (another homogeneous collection) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=,set)) and **Map<K, V>** (though from the spec, maps might be allowed heterogeneous values, which complicates static typing). We handle Set<T> similarly to List<T> – it’s basically the same as list in type terms (just different semantics). So Set<T> with adds must unify types, etc. **Map<K, V>**: If we enforce homogeneity (all keys K, all values V one type each), it’s a straightforward Map<K, V> type. If WFL allows mixed-type values in a map (as spec hints), then V could be a union or variant type. For now, if implementing static checking, we’d either disallow mixed types (recommend making values uniform) or treat the value type as a type variable that gets unified to a common supertype. If one inserts both a Number and a Text into the same map, the only common supertype might be an abstract “Variant” or simply we refuse that and say the map must have a single value type. The spec notes *“WFL doesn’t strictly require [map values] uniform... but if you plan to enforce a type, you could declare the map type explicitly or ensure only adding matching types”* ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=Here%2C%20the%20keys%20are%20,get%20%3Ckey)). To keep strong type guarantees, we’d encourage uniform types in maps, possibly treat mixing as an error or have a dynamic type fallback (beyond HM scope).

**User-Defined Generics:** In the future, WFL may let users define their own generic structures or actions. For instance, maybe an action like `define action firstElement needs: items as list of T gives back: result as T`. Internally, that would be a polymorphic function ∀T. List<T> → T. Our type checker design already supports this: T would be represented as a TypeVar in the action’s definition, and at generalization time we’d quantify it. Calls to `firstElement` would instantiate T based on the list type passed. We would need to parse “list of T” in the signature and understand T is a generic parameter. This is an extensibility point – not needed for the first stage of WFL, but possible.

**Opaque vs Parametric List Discussion:** To explicitly address *List<T> vs opaque List*: choosing **List<T>** (parametric) means the type checker enforces uniform element types and knows the element type at compile time, enabling all the checks described. Choosing an opaque (untyped) `List` would mean any list can hold any kind of element. This would simplify the type representation (just one List type) but at a **high cost**: you lose compile-time checking for element operations. For example, adding a string to a list of numbers would not be caught if the list is untyped; you’d possibly get a runtime error later when using the data. This is against WFL’s safety goals. Also, an opaque list’s content when retrieved might need to be treated as an `Any` type (or Variant) that the user then tries to use – the type checker would then have to allow “any type” which undermines type inference and safety (similar to turning off the type system). Therefore, we decidedly opt for **parametric list types** and similarly typed sets/maps. This aligns with “strong type safety with inference” principle ([wfl-foundation.md](file://file-41C7my4KV75hMCMcj4EYv8#:~:text=5)) – we infer the element type and ensure compatibility.

In summary, generics in WFL’s type system are handled via Hindley-Milner’s built-in support for type variables and unification. The checker treats generics uniformly: whether it’s the element type of a list, the field type in a record template, or a type parameter in a function, they all are just TypeVar placeholders that get unified according to usage. This approach yields flexibility (e.g. one list type definition works for all element types) while still catching errors (mismatched types in collections) at compile time. We keep the design open so that if later WFL adds **more parametric types** (like an Option<T> or other container), the same machinery applies.

## Error Handling and Reporting  
A major goal for WFL is to have **clear, actionable error messages** that help beginners understand and fix issues ([wfl-error.md](file://file-Cu94WGLkBQAeNjHazU7nKr#:~:text=Clear%20and%20Actionable%20Error%20Messages,philosophy%20of%20clarity%20and%20helpfulness)). The type checker plays a big role in this by detecting type mismatches and other static errors. We will implement an **error model** that transforms raw type errors into friendly explanations, often with hints for resolution.

Key aspects of the error model:

- **Plain Language Descriptions:** Error messages avoid jargon like “type inference failed” or “unification error at τ₀”. Instead, they phrase the problem in simple terms. For example, instead of “Cannot unify Text with Number in expression,” we say *“Expected a **number** but found **text**”* ([wfl-error.md](file://file-Cu94WGLkBQAeNjHazU7nKr#:~:text=etc,Elm%20is%20famous%20for%20error)). This directly communicates the issue (wrong types) in user-facing terms. We use the actual type names that WFL uses (Number, Text, Bool, etc. rather than internal codes).

- **Indicate Location and Context:** Thanks to AST annotation, we know exactly where an error occurs. We will highlight the offending code in any output (for instance, underline the expression in question) and attach the message to it. If the error involves two parts (like two operands with different types), the message might point out both, or the primary site and reference the other. Example: *“The value assigned to `age` needs to be a number, but here you’re assigning a text.”* This could highlight the right-hand side of the assignment and mention `age`’s definition.

- **Mention Expected vs Actual Types:** Many type errors boil down to a discrepancy between what was expected and what was given. Our error messages will follow the pattern **“Expected X but found Y”** ([wfl-error.md](file://file-Cu94WGLkBQAeNjHazU7nKr#:~:text=it,in%20WFL%20share%20this%20philosophy)). For instance:
  - *“Expected **text** but found **number**”*: If someone does `"Name: " plus 42` (assuming `plus` is numeric addition), the left is Text, plus expects both Number, so we expected a Number on left but found Text.
  - *“Expected **List of number** but found **List of text**”*: If a function needs a list of numbers but a list of strings was passed.
  - In an `if` expression context (if it were an expression), *“Both branches of an if must have the same type. The ‘then’ branch is Text but the ‘else’ branch is Number.”*

- **Specific Guidance and Hints:** We aim to not only state the problem but also guide the user to a solution ([wfl-error.md](file://file-Cu94WGLkBQAeNjHazU7nKr#:~:text=Clear%20and%20Actionable%20Error%20Messages,philosophy%20of%20clarity%20and%20helpfulness)). WFL draws inspiration from Elm’s famously helpful errors ([wfl-error.md](file://file-Cu94WGLkBQAeNjHazU7nKr#:~:text=uses%20text%20where%20a%20number,Amazing%2C%20Informative%2C%20Paternalistic%20Error)). For example:
  - If a number vs text issue is detected, after *“Expected text but found number”*, we can add *“– try converting the number to text.”*. In code, we know a number was found where text was needed, so we can guess the user might want to do `5 as text`. We incorporate that suggestion right into the message.
  - If a variable might be nothing: *“`total` might not have a value (nothing) here. Add a check `if total is nothing` before using it, or ensure `total` gets a value.”*
  - If a function call has an argument of wrong type: *“The action **add numbers** expects its **y** parameter to be a number, but you passed a text. Did you mean to remove quotes to pass a number, or use a different function?”*. This mentions the function and parameter name (we have that from the signature), making it clear which argument is wrong.
  - If an unknown field is accessed in a record: e.g., `person.phonenumber` when `person` has no such field – *“`person` has no field named `phonenumber`. Check for typos or ensure the field is defined.”* This type of error is structural (record type mismatch).
  - If a list operation is wrong type: *“Trying to add a text to a list of numbers. All items in this list must be numbers.”* 
  - If a return value is never set: *“The action **greet** is supposed to give back a text (`message`), but `message` isn’t set in all paths. Make sure to assign a value to `message` in every case.”*.

- **Error Highlighting Example:** As WFL docs note, they want to present errors like a mentor’s guidance ([wfl-error.md](file://file-Cu94WGLkBQAeNjHazU7nKr#:~:text=uses%20text%20where%20a%20number,Amazing%2C%20Informative%2C%20Paternalistic%20Error)). We might output something like:
  ```text
  Line 10: store age as "thirty"
                ^^^
  Type Error: The variable `age` was expected to be a number, but you’re assigning text here. 
  HINT: If "thirty" is meant to be a number, just write 30 (without quotes). Otherwise, change `age`’s usage to be text consistently.
  ```
  Here we highlight `"thirty"` and explain it. The hint guesses a possible fix (removing quotes to make it a number literal).

- **Multiple Errors and Terminology:** The type checker will likely find the first error and stop (to avoid cascading nonsense errors), or it could attempt to continue and gather a list of errors. For a beginner-friendly approach, it’s often best to show one error at a time – the most proximate cause – because one fix might resolve subsequent issues. We will ensure not to overwhelm with technical terms: e.g., say "value" instead of "operand" if possible, "function" or "action" instead of "lambda", etc., matching WFL’s simple terminology.

- **Integration with Documentation:** The error strings can reference the guide or common mistakes. The example above referencing quotes is a common newbie mistake (putting numbers in quotes). We can maintain a set of such patterns in the checker: if expected Number but got Text literal consisting only of digits, suggest removing quotes. If expected Text but got Number, maybe suggest adding `as text` or quotes. If a boolean was expected but a text “yes”/“no” wasn’t used correctly (though yes/no are booleans in WFL, but say user wrote "true" instead of yes), we could mention that. These heuristics make errors feel personalized and educational.

- **Severity and Recovery:** All type mismatches are compile-time **errors** (not warnings), because they will cause runtime issues if not fixed. The compiler will prevent running the program until they’re resolved. Some lesser issues (like an unused variable or an unconstrained `nothing`) might be warnings or errors depending on policy. An unconstrained `nothing` we’d likely treat as an error (“we can’t figure out what type X is”). Unused variable might be a warning.

- **Examples of Error Messages (with citations from design docs):**  
  - *Expected a number but found text — try converting it first.* – This style is explicitly desired ([wfl-error.md](file://file-Cu94WGLkBQAeNjHazU7nKr#:~:text=it,philosophy%20of%20clarity%20and%20helpfulness)) and we will use it for e.g. numeric vs string mismatches.  
  - *The value needs to be a number — check your input.* – Another phrasing from the docs ([wfl-error.md](file://file-Cu94WGLkBQAeNjHazU7nKr#:~:text=uses%20text%20where%20a%20number,Amazing%2C%20Informative%2C%20Paternalistic%20Error)). We’ll use similar gentle wording, e.g. if user input or passed a wrong type.  
  - *Expected text but found a number.* – Straight to the point for concatenation or assignment errors.  
  - *List type error:* “This list holds texts, but you’re trying to add a number. All items in `yourList` should be texts.”  
  - *Function arity error:* “The action `make greeting` expects 1 argument (name), but 2 were provided.” (if user passed extra arguments).  
  - *Record field error:* “`person` record doesn’t have `address` field. (It has name, age, email, is active.)” – showing what exists can help.  
  - *Misc:* We also ensure to handle syntax vs type errors distinctly. Syntax errors (like missing `end if`) will be caught in parsing. The type checker focuses on type-related errors.

By implementing these error messages, we turn the type checker from a mere enforcer into a teaching tool. Instead of frustrating newbies with cryptic messages, WFL’s compiler will *guide* them to the solution ([wfl-error.md](file://file-Cu94WGLkBQAeNjHazU7nKr#:~:text=Clear%20and%20Actionable%20Error%20Messages,in%20WFL%20share%20this%20philosophy)). This aligns with the language’s ethos of being welcoming and clear. Even advanced users benefit from the detail and precision of these errors, which can save time debugging. We’ll take care to cover common error scenarios with custom messages or at least ensure the general pattern is understandable.

## Extensibility and Future Directions  
The static type checker is designed with the future of WFL in mind. As WFL grows to include more features and integrate with web technologies, the type system should **extend gracefully**. We outline how this design can accommodate new additions:

- **Asynchronous and Future Types:** WFL has plans for async operations (e.g., `await perform fetch data ...`) ([wfl-spec.md](file://file-7u4rBtZo3tCwXujhdrNSPd#:~:text=match%20at%20L602%20store%20response,display%20response)). We may introduce an **Async<T>** (or Promise-like) type to represent the result of an async action. For example, an action defined as `async action fetch data gives back result as text` might actually have type `() → Async<Text>` (if no params for simplicity). The `await` keyword in WFL would take an `Async<T>` and yield `T`. To support this, we add a `Type` variant for Async or a modifier. The type checker then has a rule: if you `await E`, then E’s type must be Async<U> for some U, and the result of `await E` is U. If someone tries to await a non-async value or use an async value without awaiting where a concrete is needed, the checker will error accordingly. This addition is local: it doesn’t disturb existing rules, just adds a new expression form and type form. Because we designed the unify mechanism to be generic, unifying Async types will just unify their inner types. So if a function expects an Async<Text> and you provided Async<Number>, unification will flag the mismatch of Text vs Number as usual.
  
- **Web/DOM Element Types:** Since WFL is web-focused, it might introduce types for HTML elements, events, etc. For example, an element could be a type **Element** or even more specifically **Element<Button>**, **Element<Paragraph>**, etc. Initially, we can introduce a simple **ElementType** to represent any DOM element. Operations on elements (like adding to page, setting text) will have specific type signatures (perhaps methods or actions that take Element). If later we want more specific types (maybe a hierarchy like Button extends Element, etc.), we might consider a basic **subtyping** or nominal typing in addition to structural. The current design is largely structural and parametric, but subtyping (e.g. treating a Button as an Element) can be integrated if needed by an extension to unification (or via union types). We could also treat each specific element type as its own type (ButtonType, DivType, etc.) and allow certain operations only on those. The type checker can easily be extended with new base types and new operation rules (like a rule that you can only call `on click` handler attach on an Element or specific subtype).
  
- **Gradual Typing / Interoperability:** If WFL wants to interoperate with JavaScript, it might need an escape hatch for dynamic typing (like a type `Any` or a way to import an untyped JS value). The type system can include an **AnyType** which unifies with anything (similar to nothing but as a top type rather than bottom). If `Any` is introduced, the checker would allow assignments to/from Any freely, but flag that as needing runtime checks possibly. We’d have to be careful: Any can undermine safety, so maybe it’s only via explicit opt-in at foreign function boundaries.
  
- **Pattern Matching and Algebraic Data Types:** The design hints at more advanced features like pattern matching. If WFL introduces **enum/variant types** (e.g., an enum `Result` with variants `Ok` and `Error`, or an Option type), the type checker can handle them by treating each enum as a sum type. For instance:
  ```wfl
  enum Color:
      Red
      Green
      Blue
  end enum
  ```
  The type `Color` would be a new variant type. Literals `Red`, `Green`, `Blue` have type Color. A match expression on Color would require checking all variants. The type checker would ensure matches are exhaustive (or an `otherwise` is present) and do variant-specific environment refinements. This is standard in many ML-like type systems and fits well with HM (Hindley-Milner was originally for ML which has algebraic data types). We just need to extend the Type representation with a **VariantType(name, [types...])** for parameterized variants if any, and unify them nominally (only the exact same variant type unifies, plus their parameters).
  
- **Extensible Records / Structural typing:** If in future WFL allows more flexible records (like adding fields arbitrarily), we might incorporate a concept of row polymorphism or an “open record” type. That’s a more advanced type system feature, but not impossible. For now, we keep records simple (closed after creation).
  
- **Type Classes or Traits:** For certain features like operator overloading in a safe way (e.g., if we wanted a single `+` to work for both Number and Text concatenation), a future solution could be **ad-hoc polymorphism** via type classes (or interfaces/traits). That’s a big step (in HM, type classes extend inference with context constraints). We could plan for it by not hard-coding too many operators to specific types but rather conceptually allowing an overload set. For now, we handle it with separate keywords (“plus” vs “with”). If later they unify those, we might implement a trait like `Addable` that Number and Text both implement in different ways. The type checker then, when seeing `A + B`, would introduce a constraint “A and B must have a type that is Addable and yields that same type”. This is an advanced extension that we note is possible if needed, but not for initial implementation.
  
- **Performance and Scaling:** As more features are added, the inference algorithm’s complexity can grow. Hindley-Milner is efficient (almost linear in practice for typical code). However, adding things like subtyping or complex union types can increase complexity. If needed, we can incorporate **type annotations** from the programmer in tricky cases to guide inference (WFL already uses explicit param types in actions, which helps). The system should remain predictable and reasonably fast for typical code sizes.

- **Maintaining Beginner-Friendliness:** Any new type system feature, we ensure the error messaging and syntax keep the “English-like” style. For example, if an async function returns Async<Text> and the user forgets to await, the error might be: *“You have an asynchronous value here. Use `await` to get the actual text before using it.”* – rather than talking about monads or promises. Each feature would come with analogous straightforward rules and explanations.

- **Pluggability:** Architecturally, we can design the checker in a modular way: new expression forms or types can be added by adding new cases in the type inference function and unify function. For instance, a plugin for web components could register new types (like HTMLCanvas or so) and the operations available on them (maybe through a mini-API to the type checker). While we won’t implement a plugin system now, keeping the code organized by construct and having a clear interface for type environment and unify makes future modifications easier.

In conclusion, the static type checker as designed will serve as a robust foundation for WFL. It enforces strict type rules to prevent errors, uses Hindley-Milner inference to keep syntax clean, and produces helpful feedback for users. The type representation and inference algorithm are flexible enough to handle additional types (async, DOM, enums) and patterns (optionals, generics) as WFL evolves. By building in strong guarantees now and planning for extensibility, we ensure that WFL’s type system will remain a cornerstone of its reliability and user-friendly experience well into the future.

