//! Pattern Compiler - Converts WFL Pattern AST to Bytecode
//!
//! The pattern compiler is responsible for transforming the high-level pattern
//! AST (generated by the parser) into efficient bytecode instructions that can
//! be executed by the pattern virtual machine.

use super::PatternError;
use super::instruction::{CharClassType, Instruction, Program};
use crate::interpreter::environment::Environment;
use crate::interpreter::value::Value;
use crate::parser::ast::{Anchor, CharClass, PatternExpression, Quantifier};
use std::collections::HashMap;

/// Compiler that converts PatternExpression AST into executable bytecode.
///
/// The compiler performs a single-pass compilation of pattern AST nodes into
/// a sequence of bytecode instructions. It handles optimization, validation,
/// and capture group management during the compilation process.
///
/// ## Architecture
///
/// The compiler uses a recursive descent approach, matching the structure of
/// the pattern AST. Each AST node type has a corresponding compilation method
/// that emits appropriate bytecode instructions.
///
/// ## Features Supported
///
/// - **Literals**: Direct string matching
/// - **Character Classes**: Unicode categories, ranges, built-in classes
/// - **Quantifiers**: `*`, `+`, `?`, `{n}`, `{n,m}`
/// - **Alternatives**: OR operations with branching
/// - **Sequences**: Concatenation of patterns
/// - **Captures**: Named capture groups with backreferences
/// - **Anchors**: Start/end of string/line anchors
/// - **Lookaround**: Positive/negative lookahead and lookbehind
///
/// ## Performance Optimizations
///
/// - Empty alternatives are optimized away
/// - Literal sequences are combined when possible
/// - Unnecessary instructions are eliminated
///
/// ## Usage
///
/// ```rust
/// use wfl::pattern::compiler::PatternCompiler;
/// use wfl::parser::ast::PatternExpression;
///
/// # fn example() -> Result<(), Box<dyn std::error::Error>> {
/// let mut compiler = PatternCompiler::new();
/// let ast = PatternExpression::Literal("hello".to_string());
/// let program = compiler.compile(&ast)?;
/// # Ok(())
/// # }
/// ```
pub struct PatternCompiler {
    /// The bytecode program being built
    program: Program,
    /// Names of capture groups in declaration order
    capture_names: Vec<String>,
    /// Map from capture name to index for fast lookup
    capture_map: HashMap<String, usize>,
    /// Counter for save slots (currently unused but preserved for future use)
    save_counter: usize,
}

impl PatternCompiler {
    /// Create a new pattern compiler.
    ///
    /// The compiler starts with an empty program and no capture groups.
    /// Each compiler instance should only be used to compile a single pattern.
    pub fn new() -> Self {
        Self {
            program: Program::new(),
            capture_names: Vec::new(),
            capture_map: HashMap::new(),
            save_counter: 0,
        }
    }

    /// Compile a PatternExpression AST into executable bytecode.
    ///
    /// This is the main entry point for compilation. It recursively processes
    /// the pattern AST and generates a complete bytecode program ready for
    /// execution by the pattern VM.
    ///
    /// # Arguments
    /// * `pattern` - The root pattern AST node to compile
    ///
    /// # Returns
    /// * `Ok(Program)` - Successfully compiled bytecode program
    /// * `Err(PatternError)` - Compilation failed due to invalid pattern
    ///
    /// # Compilation Process
    /// 1. Recursively compile the pattern AST
    /// 2. Add a final `Match` instruction
    /// 3. Set program metadata (capture count, etc.)
    /// 4. Return the complete program
    ///
    /// # Examples
    /// ```rust
    /// # use wfl::pattern::PatternCompiler;
    /// # use wfl::parser::ast::PatternExpression;
    /// # fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut compiler = PatternCompiler::new();
    /// let ast = PatternExpression::Literal("test".to_string());
    /// let program = compiler.compile(&ast)?;
    /// assert!(program.instructions.len() > 0);
    /// # Ok(())
    /// # }
    /// ```
    pub fn compile(&mut self, pattern: &PatternExpression) -> Result<Program, PatternError> {
        self.compile_expression(pattern)?;
        self.program.push(Instruction::Match);

        // Set metadata
        self.program.set_num_captures(self.capture_names.len());
        self.program.set_num_saves(self.save_counter);

        Ok(self.program.clone())
    }

    /// Compile a pattern with access to the environment for resolving list references.
    ///
    /// This method allows patterns to reference list variables defined in the environment.
    /// List references are resolved at compile time and converted to alternatives.
    ///
    /// # Arguments
    /// * `pattern` - The pattern AST to compile
    /// * `env` - Environment containing variable definitions including lists
    ///
    /// # Returns
    /// * `Ok(Program)` - Successfully compiled pattern bytecode
    /// * `Err(PatternError)` - Compilation failed due to invalid pattern or undefined list
    ///
    /// # Examples
    /// ```rust
    /// # use wfl::pattern::PatternCompiler;
    /// # use wfl::parser::ast::PatternExpression;
    /// # use wfl::interpreter::environment::Environment;
    /// # fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut compiler = PatternCompiler::new();
    /// let env = Environment::new_global();
    /// let ast = PatternExpression::ListReference("my_list".to_string());
    /// let env_borrowed = env.borrow();
    /// let program = compiler.compile_with_env(&ast, &*env_borrowed)?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn compile_with_env(
        &mut self,
        pattern: &PatternExpression,
        env: &Environment,
    ) -> Result<Program, PatternError> {
        self.compile_expression_with_env(pattern, env)?;
        self.program.push(Instruction::Match);

        // Set metadata
        self.program.set_num_captures(self.capture_names.len());
        self.program.set_num_saves(self.save_counter);

        Ok(self.program.clone())
    }

    /// Get the list of capture group names in declaration order.
    ///
    /// Returns a clone of the internal capture names list. The order matches
    /// the order in which capture groups were declared in the pattern.
    ///
    /// # Returns
    /// * `Vec<String>` - Names of all capture groups found during compilation
    pub fn capture_names(&self) -> Vec<String> {
        self.capture_names.clone()
    }

    /// Compile a single pattern expression node recursively.
    ///
    /// This is the main dispatch method that handles different AST node types.
    /// Each pattern type is delegated to its specialized compilation method.
    ///
    /// # Arguments
    /// * `pattern` - The AST node to compile
    ///
    /// # Returns
    /// * `Ok(())` - Node compiled successfully
    /// * `Err(PatternError)` - Compilation failed
    fn compile_expression(&mut self, pattern: &PatternExpression) -> Result<(), PatternError> {
        match pattern {
            PatternExpression::Literal(text) => {
                self.compile_literal(text)?;
            }

            PatternExpression::CharacterClass(char_class) => {
                self.compile_char_class(char_class)?;
            }

            PatternExpression::Sequence(patterns) => {
                self.compile_sequence(patterns)?;
            }

            PatternExpression::Alternative(patterns) => {
                self.compile_alternative(patterns)?;
            }

            PatternExpression::Quantified {
                pattern,
                quantifier,
            } => {
                self.compile_quantified(pattern, quantifier)?;
            }

            PatternExpression::Capture { name, pattern } => {
                self.compile_capture(name, pattern)?;
            }

            PatternExpression::Backreference(name) => {
                self.compile_backreference(name)?;
            }

            PatternExpression::Anchor(anchor) => {
                self.compile_anchor(anchor)?;
            }

            PatternExpression::Lookahead(pattern) => {
                self.compile_lookahead(pattern)?;
            }

            PatternExpression::NegativeLookahead(pattern) => {
                self.compile_negative_lookahead(pattern)?;
            }

            PatternExpression::Lookbehind(pattern) => {
                self.compile_lookbehind(pattern)?;
            }

            PatternExpression::NegativeLookbehind(pattern) => {
                self.compile_negative_lookbehind(pattern)?;
            }

            PatternExpression::ListReference(_name) => {
                return Err(PatternError::CompileError(
                    "List references require environment context for compilation. Use compile_with_env() instead.".to_string(),
                ));
            }
        }
        Ok(())
    }

    /// Compile a single pattern expression node recursively with environment access.
    ///
    /// This is similar to `compile_expression` but allows resolving list references
    /// from the provided environment. List references are resolved at compile time
    /// and converted to alternative patterns.
    ///
    /// # Arguments
    /// * `pattern` - The AST node to compile
    /// * `env` - Environment containing variable definitions
    ///
    /// # Returns
    /// * `Ok(())` - Node compiled successfully
    /// * `Err(PatternError)` - Compilation failed or list not found
    fn compile_expression_with_env(
        &mut self,
        pattern: &PatternExpression,
        env: &Environment,
    ) -> Result<(), PatternError> {
        match pattern {
            PatternExpression::ListReference(name) => {
                self.compile_list_reference(name, env)?;
            }

            // For all other patterns, recursively handle any nested list references
            _ => {
                let resolved_pattern = self.resolve_list_references(pattern, env)?;
                self.compile_expression(&resolved_pattern)?;
            }
        }
        Ok(())
    }

    /// Recursively resolve list references in a pattern expression.
    ///
    /// This method traverses the pattern AST and replaces any ListReference nodes
    /// with Alternative nodes containing the list elements.
    #[allow(clippy::only_used_in_recursion)]
    fn resolve_list_references(
        &self,
        pattern: &PatternExpression,
        env: &Environment,
    ) -> Result<PatternExpression, PatternError> {
        match pattern {
            PatternExpression::ListReference(name) => {
                // Look up the list variable in the environment
                match env.get(name) {
                    Some(Value::List(list_items)) => {
                        // Convert list items to literal patterns
                        let list_borrow = list_items.borrow();
                        let alternatives: Result<Vec<_>, _> = list_borrow.iter()
                            .map(|item| match item {
                                Value::Text(s) => Ok(PatternExpression::Literal(s.to_string())),
                                _ => Err(PatternError::CompileError(
                                    format!("List '{}' contains non-text element. Pattern lists must contain only text values.", name)
                                ))
                            })
                            .collect();

                        let alternatives = alternatives?;
                        if alternatives.is_empty() {
                            return Err(PatternError::CompileError(format!(
                                "List '{}' is empty. Patterns cannot match empty alternatives.",
                                name
                            )));
                        }

                        if alternatives.len() == 1 {
                            Ok(alternatives.into_iter().next().unwrap())
                        } else {
                            Ok(PatternExpression::Alternative(alternatives))
                        }
                    }
                    Some(_) => Err(PatternError::CompileError(format!(
                        "'{}' is not a list variable. Only list variables can be referenced in patterns.",
                        name
                    ))),
                    None => Err(PatternError::CompileError(format!(
                        "List '{}' is not defined in the current scope.",
                        name
                    ))),
                }
            }

            PatternExpression::Sequence(patterns) => {
                let resolved: Result<Vec<_>, _> = patterns
                    .iter()
                    .map(|p| self.resolve_list_references(p, env))
                    .collect();
                Ok(PatternExpression::Sequence(resolved?))
            }

            PatternExpression::Alternative(patterns) => {
                let resolved: Result<Vec<_>, _> = patterns
                    .iter()
                    .map(|p| self.resolve_list_references(p, env))
                    .collect();
                Ok(PatternExpression::Alternative(resolved?))
            }

            PatternExpression::Quantified {
                pattern,
                quantifier,
            } => {
                let resolved = self.resolve_list_references(pattern, env)?;
                Ok(PatternExpression::Quantified {
                    pattern: Box::new(resolved),
                    quantifier: quantifier.clone(),
                })
            }

            PatternExpression::Capture { name, pattern } => {
                let resolved = self.resolve_list_references(pattern, env)?;
                Ok(PatternExpression::Capture {
                    name: name.clone(),
                    pattern: Box::new(resolved),
                })
            }

            // For these node types, just return as-is since they don't contain nested patterns
            PatternExpression::Literal(_)
            | PatternExpression::CharacterClass(_)
            | PatternExpression::Backreference(_)
            | PatternExpression::Anchor(_) => Ok(pattern.clone()),

            // For lookaround patterns, resolve nested patterns
            PatternExpression::Lookahead(pattern) => {
                let resolved = self.resolve_list_references(pattern, env)?;
                Ok(PatternExpression::Lookahead(Box::new(resolved)))
            }

            PatternExpression::NegativeLookahead(pattern) => {
                let resolved = self.resolve_list_references(pattern, env)?;
                Ok(PatternExpression::NegativeLookahead(Box::new(resolved)))
            }

            PatternExpression::Lookbehind(pattern) => {
                let resolved = self.resolve_list_references(pattern, env)?;
                Ok(PatternExpression::Lookbehind(Box::new(resolved)))
            }

            PatternExpression::NegativeLookbehind(pattern) => {
                let resolved = self.resolve_list_references(pattern, env)?;
                Ok(PatternExpression::NegativeLookbehind(Box::new(resolved)))
            }
        }
    }

    /// Compile a list reference by resolving it from the environment.
    fn compile_list_reference(
        &mut self,
        name: &str,
        env: &Environment,
    ) -> Result<(), PatternError> {
        let resolved =
            self.resolve_list_references(&PatternExpression::ListReference(name.to_string()), env)?;
        self.compile_expression(&resolved)
    }

    /// Compile a literal string into matching instructions.
    ///
    /// Optimizes single characters to use `Char` instruction for efficiency.
    /// Multi-character strings use the `Literal` instruction.
    ///
    /// # Arguments
    /// * `text` - The literal string to match
    fn compile_literal(&mut self, text: &str) -> Result<(), PatternError> {
        if text.is_empty() {
            return Ok(()); // Empty string matches trivially
        }

        if text.len() == 1 {
            // Single character - use Char instruction
            let ch = text.chars().next().unwrap();
            self.program.push(Instruction::Char(ch));
        } else {
            // Multi-character string - use Literal instruction
            self.program.push(Instruction::Literal(text.to_string()));
        }
        Ok(())
    }

    /// Compile a character class into a CharClass instruction.
    ///
    /// Maps WFL character class types to bytecode character class types.
    /// Supports built-in classes (digit, letter, whitespace) and Unicode
    /// categories, scripts, and properties.
    ///
    /// # Arguments
    /// * `char_class` - The character class AST node to compile
    fn compile_char_class(&mut self, char_class: &CharClass) -> Result<(), PatternError> {
        let class_type = match char_class {
            CharClass::Digit => CharClassType::Digit,
            CharClass::Letter => CharClassType::Letter,
            CharClass::Whitespace => CharClassType::Whitespace,
            CharClass::Any => CharClassType::Any,
            CharClass::UnicodeCategory(category) => {
                CharClassType::UnicodeCategory(category.clone())
            }
            CharClass::UnicodeScript(script) => CharClassType::UnicodeScript(script.clone()),
            CharClass::UnicodeProperty(property) => {
                CharClassType::UnicodeProperty(property.clone())
            }
        };
        self.program.push(Instruction::CharClass(class_type));
        Ok(())
    }

    /// Compile a sequence of patterns (concatenation).
    ///
    /// Compiles each pattern in order. The patterns must all match
    /// consecutively for the sequence to match.
    ///
    /// # Arguments
    /// * `patterns` - The list of patterns to match in sequence
    fn compile_sequence(&mut self, patterns: &[PatternExpression]) -> Result<(), PatternError> {
        for pattern in patterns {
            self.compile_expression(pattern)?;
        }
        Ok(())
    }

    /// Compile alternative patterns (alternation)
    fn compile_alternative(&mut self, patterns: &[PatternExpression]) -> Result<(), PatternError> {
        if patterns.is_empty() {
            return Err(PatternError::CompileError("Empty alternative".to_string()));
        }

        if patterns.len() == 1 {
            return self.compile_expression(&patterns[0]);
        }

        // Generate code structure:
        // split L1, L2
        // <pattern1>
        // jump END
        // L1: split L3, L4  (if more alternatives)
        // <pattern2>
        // jump END
        // L2: <pattern3>
        // END:

        let mut jump_to_end = Vec::new();
        let _split_locations: Vec<usize> = Vec::new();

        // For each alternative except the last, emit a split
        for (i, pattern) in patterns.iter().enumerate() {
            if i == patterns.len() - 1 {
                // Last alternative - just compile it
                self.compile_expression(pattern)?;
            } else {
                // Not the last - emit split and compile pattern
                let split_addr = self.program.len();
                self.program.push(Instruction::Split(0, 0)); // Will be patched

                self.compile_expression(pattern)?;

                // Jump to end after this alternative succeeds
                let jump_addr = self.program.len();
                self.program.push(Instruction::Jump(0)); // Will be patched
                jump_to_end.push(jump_addr);

                // Patch the split to point to the next alternative
                let next_alternative_addr = self.program.len();
                if let Some(Instruction::Split(first, second)) =
                    self.program.instructions.get_mut(split_addr)
                {
                    *first = split_addr + 1; // Next instruction (the pattern)
                    *second = next_alternative_addr; // Next alternative (will be filled next iteration)
                }
            }
        }

        // Patch all jump-to-end instructions
        let end_addr = self.program.len();
        for jump_addr in jump_to_end {
            if let Some(Instruction::Jump(target)) = self.program.instructions.get_mut(jump_addr) {
                *target = end_addr;
            }
        }

        Ok(())
    }

    /// Compile a quantified pattern
    fn compile_quantified(
        &mut self,
        pattern: &PatternExpression,
        quantifier: &Quantifier,
    ) -> Result<(), PatternError> {
        match quantifier {
            Quantifier::Optional => {
                // Optional: split to pattern or skip
                // split L1, L2
                // L1: <pattern>
                // L2: (continue)

                let split_addr = self.program.len();
                self.program.push(Instruction::Split(0, 0)); // Will be patched

                self.compile_expression(pattern)?;

                let end_addr = self.program.len();

                // Patch split
                if let Some(Instruction::Split(first, second)) =
                    self.program.instructions.get_mut(split_addr)
                {
                    *first = split_addr + 1; // Try the pattern
                    *second = end_addr; // Or skip it
                }
            }

            Quantifier::ZeroOrMore => {
                // Zero or more: split to pattern or skip, with loop back
                // L1: split L2, L3
                // L2: <pattern>
                //     jump L1
                // L3: (continue)

                let loop_start = self.program.len();
                self.program.push(Instruction::Split(0, 0)); // Will be patched

                self.compile_expression(pattern)?;

                // Jump back to loop start
                self.program.push(Instruction::Jump(loop_start));

                let end_addr = self.program.len();

                // Patch split
                if let Some(Instruction::Split(first, second)) =
                    self.program.instructions.get_mut(loop_start)
                {
                    *first = loop_start + 1; // Try the pattern
                    *second = end_addr; // Or exit loop
                }
            }

            Quantifier::OneOrMore => {
                // One or more: pattern, then optional loop
                // <pattern>
                // L1: split L2, L3
                // L2: <pattern>
                //     jump L1
                // L3: (continue)

                self.compile_expression(pattern)?;

                let loop_start = self.program.len();
                self.program.push(Instruction::Split(0, 0)); // Will be patched

                self.compile_expression(pattern)?;

                // Jump back to loop start
                self.program.push(Instruction::Jump(loop_start));

                let end_addr = self.program.len();

                // Patch split
                if let Some(Instruction::Split(first, second)) =
                    self.program.instructions.get_mut(loop_start)
                {
                    *first = loop_start + 1; // Try another iteration
                    *second = end_addr; // Or exit loop
                }
            }

            Quantifier::Exactly(n) => {
                // Exactly N: just repeat the pattern N times
                for _ in 0..*n {
                    self.compile_expression(pattern)?;
                }
            }

            Quantifier::Between(min, max) => {
                // Between min and max: first min required, then up to (max-min) optional

                // Required repetitions
                for _ in 0..*min {
                    self.compile_expression(pattern)?;
                }

                // Optional repetitions
                let optional_count = max - min;
                for _ in 0..optional_count {
                    let split_addr = self.program.len();
                    self.program.push(Instruction::Split(0, 0)); // Will be patched

                    self.compile_expression(pattern)?;

                    let end_addr = self.program.len();

                    // Patch split
                    if let Some(Instruction::Split(first, second)) =
                        self.program.instructions.get_mut(split_addr)
                    {
                        *first = split_addr + 1; // Try the pattern
                        *second = end_addr; // Or skip it
                    }
                }
            }

            Quantifier::AtLeast(n) => {
                // At least N: first N required, then zero or more optional

                // Required repetitions
                for _ in 0..*n {
                    self.compile_expression(pattern)?;
                }

                // Then zero or more (same as ZeroOrMore logic)
                let loop_start = self.program.len();
                self.program.push(Instruction::Split(0, 0)); // Will be patched

                self.compile_expression(pattern)?;

                // Jump back to loop start
                self.program.push(Instruction::Jump(loop_start));

                let end_addr = self.program.len();

                // Patch split
                if let Some(Instruction::Split(first, second)) =
                    self.program.instructions.get_mut(loop_start)
                {
                    *first = loop_start + 1; // Try the pattern
                    *second = end_addr; // Or exit loop
                }
            }

            Quantifier::AtMost(n) => {
                // At most N: all repetitions are optional, up to N

                for _ in 0..*n {
                    let split_addr = self.program.len();
                    self.program.push(Instruction::Split(0, 0)); // Will be patched

                    self.compile_expression(pattern)?;

                    let end_addr = self.program.len();

                    // Patch split
                    if let Some(Instruction::Split(first, second)) =
                        self.program.instructions.get_mut(split_addr)
                    {
                        *first = split_addr + 1; // Try the pattern
                        *second = end_addr; // Or skip it
                    }
                }
            }
        }

        Ok(())
    }

    /// Compile a capture group
    fn compile_capture(
        &mut self,
        name: &str,
        pattern: &PatternExpression,
    ) -> Result<(), PatternError> {
        // Assign capture index
        let capture_index = if let Some(&index) = self.capture_map.get(name) {
            index
        } else {
            let index = self.capture_names.len();
            self.capture_names.push(name.to_string());
            self.capture_map.insert(name.to_string(), index);
            index
        };

        // Start capture
        self.program.push(Instruction::StartCapture(capture_index));

        // Compile the pattern
        self.compile_expression(pattern)?;

        // End capture
        self.program.push(Instruction::EndCapture(capture_index));

        Ok(())
    }

    /// Compile a backreference
    fn compile_backreference(&mut self, name: &str) -> Result<(), PatternError> {
        // Look up the capture index by name
        if let Some(&capture_index) = self.capture_map.get(name) {
            self.program.push(Instruction::Backreference(capture_index));
            Ok(())
        } else {
            Err(PatternError::CompileError(format!(
                "Backreference to undefined capture group: '{name}'"
            )))
        }
    }

    /// Compile an anchor
    fn compile_anchor(&mut self, anchor: &Anchor) -> Result<(), PatternError> {
        match anchor {
            Anchor::StartOfText => {
                self.program.push(Instruction::StartAnchor);
            }
            Anchor::EndOfText => {
                self.program.push(Instruction::EndAnchor);
            }
        }
        Ok(())
    }

    /// Compile a positive lookahead
    fn compile_lookahead(&mut self, pattern: &PatternExpression) -> Result<(), PatternError> {
        // For lookaheads, we need to:
        // 1. Begin lookahead (saves position)
        // 2. Compile the pattern to check
        // 3. End lookahead (restores position if pattern matched)
        self.program.push(Instruction::BeginLookahead);
        self.compile_expression(pattern)?;
        self.program.push(Instruction::EndLookahead);
        Ok(())
    }

    /// Compile a negative lookahead
    fn compile_negative_lookahead(
        &mut self,
        pattern: &PatternExpression,
    ) -> Result<(), PatternError> {
        // For negative lookaheads:
        // 1. Begin negative lookahead (saves position)
        // 2. Compile the pattern to check
        // 3. End negative lookahead (restores position if pattern didn't match)
        self.program.push(Instruction::BeginNegativeLookahead);
        self.compile_expression(pattern)?;
        self.program.push(Instruction::EndNegativeLookahead);
        Ok(())
    }

    /// Compile a positive lookbehind
    fn compile_lookbehind(&mut self, pattern: &PatternExpression) -> Result<(), PatternError> {
        // Create a separate program for the lookbehind pattern
        let mut lookbehind_compiler = PatternCompiler::new();
        lookbehind_compiler.compile_expression(pattern)?;
        lookbehind_compiler.program.push(Instruction::Match);

        // Embed the lookbehind program in the instruction
        self.program.push(Instruction::CheckLookbehind(Box::new(
            lookbehind_compiler.program,
        )));

        Ok(())
    }

    /// Compile a negative lookbehind
    fn compile_negative_lookbehind(
        &mut self,
        pattern: &PatternExpression,
    ) -> Result<(), PatternError> {
        // Create a separate program for the negative lookbehind pattern
        let mut lookbehind_compiler = PatternCompiler::new();
        lookbehind_compiler.compile_expression(pattern)?;
        lookbehind_compiler.program.push(Instruction::Match);

        // Embed the lookbehind program in the instruction
        self.program
            .push(Instruction::CheckNegativeLookbehind(Box::new(
                lookbehind_compiler.program,
            )));

        Ok(())
    }

    /// Calculate the fixed length of a pattern (if possible)
    #[allow(dead_code)]
    #[allow(clippy::only_used_in_recursion)]
    fn calculate_pattern_length(&self, pattern: &PatternExpression) -> Option<usize> {
        match pattern {
            PatternExpression::Literal(s) => Some(s.chars().count()),
            PatternExpression::CharacterClass(_) => Some(1),
            PatternExpression::Sequence(patterns) => {
                let mut total = 0;
                for p in patterns {
                    total += self.calculate_pattern_length(p)?;
                }
                Some(total)
            }
            PatternExpression::Capture { pattern, .. } => self.calculate_pattern_length(pattern),
            _ => None, // Quantifiers, alternatives, etc. don't have fixed length
        }
    }
}

impl Default for PatternCompiler {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::ast::{CharClass, PatternExpression, Quantifier};

    #[test]
    fn test_compile_literal() {
        let mut compiler = PatternCompiler::new();
        let pattern = PatternExpression::Literal("hello".to_string());

        let program = compiler.compile(&pattern).unwrap();

        assert_eq!(program.instructions.len(), 2); // Literal + Match
        match &program.instructions[0] {
            Instruction::Literal(text) => assert_eq!(text, "hello"),
            _ => panic!("Expected Literal instruction"),
        }
        assert_eq!(program.instructions[1], Instruction::Match);
    }

    #[test]
    fn test_compile_single_char() {
        let mut compiler = PatternCompiler::new();
        let pattern = PatternExpression::Literal("a".to_string());

        let program = compiler.compile(&pattern).unwrap();

        assert_eq!(program.instructions.len(), 2); // Char + Match
        match &program.instructions[0] {
            Instruction::Char(ch) => assert_eq!(*ch, 'a'),
            _ => panic!("Expected Char instruction"),
        }
    }

    #[test]
    fn test_compile_char_class() {
        let mut compiler = PatternCompiler::new();
        let pattern = PatternExpression::CharacterClass(CharClass::Digit);

        let program = compiler.compile(&pattern).unwrap();

        assert_eq!(program.instructions.len(), 2); // CharClass + Match
        match &program.instructions[0] {
            Instruction::CharClass(CharClassType::Digit) => {}
            _ => panic!("Expected CharClass(Digit) instruction"),
        }
    }

    #[test]
    fn test_compile_sequence() {
        let mut compiler = PatternCompiler::new();
        let pattern = PatternExpression::Sequence(vec![
            PatternExpression::Literal("a".to_string()),
            PatternExpression::CharacterClass(CharClass::Digit),
            PatternExpression::Literal("b".to_string()),
        ]);

        let program = compiler.compile(&pattern).unwrap();

        assert_eq!(program.instructions.len(), 4); // Char + CharClass + Char + Match
        assert_eq!(program.instructions[0], Instruction::Char('a'));
        assert_eq!(
            program.instructions[1],
            Instruction::CharClass(CharClassType::Digit)
        );
        assert_eq!(program.instructions[2], Instruction::Char('b'));
        assert_eq!(program.instructions[3], Instruction::Match);
    }

    #[test]
    fn test_compile_optional() {
        let mut compiler = PatternCompiler::new();
        let pattern = PatternExpression::Quantified {
            pattern: Box::new(PatternExpression::Literal("a".to_string())),
            quantifier: Quantifier::Optional,
        };

        let program = compiler.compile(&pattern).unwrap();

        // Should have: Split, Char, Match
        assert_eq!(program.instructions.len(), 3);
        match &program.instructions[0] {
            Instruction::Split(first, second) => {
                assert_eq!(*first, 1); // Try the character
                assert_eq!(*second, 2); // Or skip to Match
            }
            _ => panic!("Expected Split instruction"),
        }
        assert_eq!(program.instructions[1], Instruction::Char('a'));
        assert_eq!(program.instructions[2], Instruction::Match);
    }

    #[test]
    fn test_compile_capture() {
        let mut compiler = PatternCompiler::new();
        let pattern = PatternExpression::Capture {
            name: "test".to_string(),
            pattern: Box::new(PatternExpression::Literal("hello".to_string())),
        };

        let program = compiler.compile(&pattern).unwrap();
        let capture_names = compiler.capture_names();

        assert_eq!(capture_names, vec!["test"]);
        assert_eq!(program.num_captures, 1);

        // Should have: StartCapture, Literal, EndCapture, Match
        assert_eq!(program.instructions.len(), 4);
        assert_eq!(program.instructions[0], Instruction::StartCapture(0));
        match &program.instructions[1] {
            Instruction::Literal(text) => assert_eq!(text, "hello"),
            _ => panic!("Expected Literal instruction"),
        }
        assert_eq!(program.instructions[2], Instruction::EndCapture(0));
        assert_eq!(program.instructions[3], Instruction::Match);
    }
}
