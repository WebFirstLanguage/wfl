use crate::error::PackageError;
use crate::lockfile::{LockFile, LockedDependency, LockedPackage};
use crate::manifest::version::Version;

/// Parse a `project.lock` file from its text content.
pub fn parse_lock_file(content: &str) -> Result<LockFile, PackageError> {
    let mut packages = Vec::new();
    let mut current_package: Option<LockedPackage> = None;
    for (line_num, raw_line) in content.lines().enumerate().map(|(i, l)| (i + 1, l)) {
        let line = raw_line.trim_end();

        // Skip empty lines and comments
        if line.trim().is_empty() || line.trim().starts_with("//") {
            continue;
        }

        // Check if this is a top-level "package <name>" line
        if let Some(rest) = line.strip_prefix("package ") {
            // Save previous package
            if let Some(pkg) = current_package.take() {
                packages.push(pkg);
            }
            let name = rest.trim().to_string();
            current_package = Some(LockedPackage {
                name,
                version: Version::new(0, 1, Some(0)),
                checksum: String::new(),
                dependencies: Vec::new(),
            });
            continue;
        }

        // Indented lines belong to the current package
        if line.starts_with("  ") {
            let inner = line.trim();
            if let Some(ref mut pkg) = current_package {
                if let Some(rest) = inner.strip_prefix("version is ") {
                    pkg.version = Version::parse(rest.trim()).map_err(|_| {
                        PackageError::LockFileParseError {
                            line: line_num,
                            message: format!("Invalid version: {}", rest.trim()),
                        }
                    })?;
                } else if let Some(rest) = inner.strip_prefix("checksum is ") {
                    pkg.checksum = rest.trim().to_string();
                } else if let Some(rest) = inner.strip_prefix("requires ") {
                    // "requires text-utils 25.11.2"
                    let parts: Vec<&str> = rest.trim().splitn(2, ' ').collect();
                    if parts.len() == 2 {
                        let dep_name = parts[0].to_string();
                        let dep_version = Version::parse(parts[1]).map_err(|_| {
                            PackageError::LockFileParseError {
                                line: line_num,
                                message: format!("Invalid dependency version: {}", parts[1]),
                            }
                        })?;
                        pkg.dependencies.push(LockedDependency {
                            name: dep_name,
                            version: dep_version,
                        });
                    } else {
                        return Err(PackageError::LockFileParseError {
                            line: line_num,
                            message: format!(
                                "Malformed requires line, expected 'requires <name> <version>': {}",
                                rest.trim()
                            ),
                        });
                    }
                } else {
                    return Err(PackageError::LockFileParseError {
                        line: line_num,
                        message: format!("Unrecognized field in package block: {}", inner),
                    });
                }
            } else {
                return Err(PackageError::LockFileParseError {
                    line: line_num,
                    message: "Found indented line without a preceding package declaration"
                        .to_string(),
                });
            }
            continue;
        }

        return Err(PackageError::LockFileParseError {
            line: line_num,
            message: format!("Unexpected line: {}", line),
        });
    }

    // Save last package
    if let Some(pkg) = current_package {
        packages.push(pkg);
    }

    Ok(LockFile { packages })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_lock_file() {
        let content = "\
// Auto-generated by WFL. Do not edit.
// Records exact versions for reproducible builds.

package http-client
  version is 26.1.3
  checksum is wflhash:a3f8b2c9d4e5f6a7

package json-parser
  version is 25.12.8
  checksum is wflhash:b4c5d6e7f8a9b0c1
  requires text-utils 25.11.2

package text-utils
  version is 25.11.2
  checksum is wflhash:c5d6e7f8a9b0c1d2
";
        let lock = parse_lock_file(content).unwrap();
        assert_eq!(lock.packages.len(), 3);

        assert_eq!(lock.packages[0].name, "http-client");
        assert_eq!(lock.packages[0].version.to_string(), "26.1.3");
        assert!(lock.packages[0].checksum.starts_with("wflhash:"));

        assert_eq!(lock.packages[1].name, "json-parser");
        assert_eq!(lock.packages[1].dependencies.len(), 1);
        assert_eq!(lock.packages[1].dependencies[0].name, "text-utils");
    }
}
