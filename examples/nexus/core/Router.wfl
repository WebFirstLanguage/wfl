// Nexus Framework - Router Module (The "Traffic Cop")
// This module handles request routing with a specific hierarchy of laziness:
// 1. Check for static files first (easiest - just serve the file)
// 2. Check dynamic routes second (requires running a script)
// 3. Return 404 as fallback (nothing matched)

// Response container for standardized responses
create container Response:
    property body_content: Text
    property status_code: Number
    property mime_type: Text
    
    action initialize needs body: Text, status: Number, content_type: Text:
        change body_content to body
        change status_code to status
        change mime_type to content_type
    end action
end container

// Route entry container for dynamic routes
create container RouteEntry:
    property url_path: Text
    property handler_name: Text
    property http_method: Text
    
    action initialize needs path_val: Text, handler_val: Text, method_val: Text:
        change url_path to path_val
        change handler_name to handler_val
        change http_method to method_val
    end action
end container

// The main Router container
create container Router:
    property web_root: Text
    property routes: List
    property route_count: Number
    property handlers: Container
    
    // Initialize the router with the web root directory
    action initialize needs root_dir: Text:
        change web_root to root_dir
        change routes to []
        change route_count to 0
        change handlers to create map
    end action
    
    // Add a dynamic route
    // Maps a URL path to a handler action name
    action add_route needs http_method: Text, url_path: Text, handler_name: Text:
        create new RouteEntry as route
        route.initialize with url_path and handler_name and http_method
        
        push with routes and route
        change route_count to route_count plus 1
        
        display "Added route: " with http_method with " " with url_path with " -> " with handler_name
    end action
    
    // Add a handler action
    // Stores a reference to the handler for later execution
    action add_handler needs handler_name: Text, handler_action: Container:
        change handlers[handler_name] to handler_action
    end action
    
    // Sanitize the request path to prevent directory traversal attacks
    // Returns a safe path or nothing if the path is malicious
    action sanitize_path needs request_path: Text:
        // Check for directory traversal attempts
        check if request_path contains "..":
            display "Security: Blocked directory traversal attempt: " with request_path
            give back nothing
        end check
        
        // Check for null bytes
        check if request_path contains "\0":
            display "Security: Blocked null byte injection: " with request_path
            give back nothing
        end check
        
        // Remove leading slash for path joining
        store clean_path as request_path
        check if clean_path starts with "/":
            store path_len as length of clean_path
            check if path_len is greater than 1:
                change clean_path to substring of clean_path from 1 to path_len
            otherwise:
                change clean_path to ""
            end check
        end check
        
        give back clean_path
    end action
    
    // Get the MIME type based on file extension
    action get_mime_type needs file_path: Text:
        check if file_path ends with ".html":
            give back "text/html"
        end check
        check if file_path ends with ".css":
            give back "text/css"
        end check
        check if file_path ends with ".js":
            give back "application/javascript"
        end check
        check if file_path ends with ".json":
            give back "application/json"
        end check
        check if file_path ends with ".png":
            give back "image/png"
        end check
        check if file_path ends with ".jpg":
            give back "image/jpeg"
        end check
        check if file_path ends with ".jpeg":
            give back "image/jpeg"
        end check
        check if file_path ends with ".gif":
            give back "image/gif"
        end check
        check if file_path ends with ".svg":
            give back "image/svg+xml"
        end check
        check if file_path ends with ".ico":
            give back "image/x-icon"
        end check
        check if file_path ends with ".txt":
            give back "text/plain"
        end check
        check if file_path ends with ".xml":
            give back "application/xml"
        end check
        check if file_path ends with ".woff":
            give back "font/woff"
        end check
        check if file_path ends with ".woff2":
            give back "font/woff2"
        end check
        
        // Default to octet-stream for unknown types
        give back "application/octet-stream"
    end action
    
    // THE RESOLUTION ALGORITHM
    // This is the core of the Router - implements the "hierarchy of laziness"
    action resolve needs incoming_request: Container:
        store request_path as path
        store request_method as method
        
        display "Router resolving: " with request_method with " " with request_path
        
        // STEP 1: STATIC FILE BYPASS (The Laziness Protocol)
        // Try to serve a static file first - this is the easiest thing to do
        store static_response as try_static_file with request_path
        check if static_response is not equal to nothing:
            display "Router: Serving static file for " with request_path
            give back static_response
        end check
        
        // STEP 2: DYNAMIC ROUTE LOOKUP
        // No static file found, check the registered dynamic routes
        store dynamic_response as try_dynamic_route with request_method and request_path
        check if dynamic_response is not equal to nothing:
            display "Router: Matched dynamic route for " with request_path
            give back dynamic_response
        end check
        
        // STEP 3: 404 FALLBACK
        // Neither static file nor dynamic route matched
        display "Router: No match found for " with request_path with " - returning 404"
        give back create_404_response with request_path
    end action
    
    // Try to serve a static file from the web root
    // Checks for exact path match and .html extension for pretty URLs
    action try_static_file needs request_path: Text:
        // Sanitize the path first
        store safe_path as sanitize_path with request_path
        check if safe_path is equal to nothing:
            give back nothing
        end check
        
        // Handle root path - serve index.html
        check if safe_path is equal to "" or safe_path is equal to "/":
            change safe_path to "index.html"
        end check
        
        // Build the full file path
        store full_path as web_root with "/" with safe_path
        
        // Check 1: Does the exact file exist?
        check if file exists at full_path:
            store file_content as read content from full_path
            store mime_type as get_mime_type with full_path
            
            create new Response as resp
            resp.initialize with file_content and 200 and mime_type
            give back resp
        end check
        
        // Check 2: Does path + .html exist? (Pretty URLs)
        store html_path as full_path with ".html"
        check if file exists at html_path:
            store file_content as read content from html_path
            
            create new Response as resp
            resp.initialize with file_content and 200 and "text/html"
            give back resp
        end check
        
        // No static file found
        give back nothing
    end action
    
    // Try to match a dynamic route and execute its handler
    action try_dynamic_route needs request_method: Text, request_path: Text:
        // Iterate through registered routes to find a match
        for each route in routes:
            store route_method as route.http_method
            store route_path as route.url_path
            
            // Check if method matches (or route accepts any method with "*")
            check if route_method is equal to request_method or route_method is equal to "*":
                // Check if path matches (exact match for now)
                // TODO: Add pattern matching support for route parameters
                check if route_path is equal to request_path:
                    // Found a match - execute the handler
                    store handler_name as route.handler_name
                    
                    // Look up the handler
                    check if handlers contains handler_name:
                        store handler as handlers[handler_name]
                        
                        // Execute the handler and return its response
                        store handler_response as handler.handle with request_method and request_path and body
                        give back handler_response
                    otherwise:
                        display "Warning: Handler not found: " with handler_name
                        store error_msg as "Handler not found: " with handler_name
                        give back create_500_response with error_msg
                    end check
                end check
            end check
        end for
        
        // No matching route found
        give back nothing
    end action
    
    // Create a 404 Not Found response
    action create_404_response needs request_path: Text:
        store error_body as "<!DOCTYPE html><html><head><title>404 Not Found</title></head><body><h1>404 Not Found</h1><p>The requested path '" with request_path with "' was not found on this server.</p></body></html>"
        
        create new Response as resp
        resp.initialize with error_body and 404 and "text/html"
        give back resp
    end action
    
    // Create a 500 Internal Server Error response
    action create_500_response needs error_message: Text:
        store error_body as "<!DOCTYPE html><html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1><p>" with error_message with "</p></body></html>"
        
        create new Response as resp
        resp.initialize with error_body and 500 and "text/html"
        give back resp
    end action
end container

// Factory function to create a configured router instance
define action called create_router needs root_dir: Text:
    create new Router as rtr
    rtr.initialize with root_dir
    give back rtr
end action
