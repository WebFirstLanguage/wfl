name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always

jobs:
  fmt:
    name: Check formatting
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt
      - name: Check formatting
        run: cargo fmt --all -- --check

  clippy-and-test:
    name: Build, Test, Clippy
    runs-on: ubuntu-latest
    needs: fmt
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      # Cache Cargo registry and target directory for faster builds
      - name: Cache Cargo registry and target directory
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: ci-build-cache

      # Build debug version first (for development workflow compatibility)
      - name: Build (Debug)
        run: cargo build --verbose

      # Build release version (required for integration tests)
      - name: Build (Release)
        run: cargo build --release --verbose

      # Run tests (integration tests now have access to release binary)
      - name: Run Tests
        run: cargo test --verbose

      # Run Clippy for code quality
      - name: Run Clippy
        run: cargo clippy --all-targets -- -D warnings

  # Cross-platform integration test verification
  integration-tests:
    name: Integration Tests
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    needs: fmt
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable

      # Cache Cargo registry and target directory for faster builds
      - name: Cache Cargo registry and target directory
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: integration-${{ matrix.os }}

      # Build release version (required for integration tests)
      - name: Build Release Binary
        run: cargo build --release --verbose

      # Verify release binary exists (platform-specific paths)
      - name: Verify Release Binary (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          if [ ! -f "target/release/wfl" ]; then
            echo "::error::Release binary not found at target/release/wfl"
            exit 1
          fi
          echo "✓ Release binary found: target/release/wfl"

      - name: Verify Release Binary (Windows)
        if: runner.os == 'Windows'
        run: |
          if (!(Test-Path "target/release/wfl.exe")) {
            Write-Host "::error::Release binary not found at target/release/wfl.exe"
            exit 1
          }
          Write-Host "✓ Release binary found: target/release/wfl.exe"

      # Run integration tests specifically
      - name: Run Integration Tests
        run: cargo test --test split_functionality --verbose

      # Run all integration tests to ensure comprehensive coverage
      - name: Run All Integration Tests
        run: cargo test --test '*' --verbose

  # Run WFL test programs to verify the interpreter works correctly
  run-wfl-programs:
    name: Run WFL Programs
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    needs: fmt
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable

      # Cache Cargo registry and target directory for faster builds
      - name: Cache Cargo registry and target directory
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: wfl-programs-${{ matrix.os }}

      # Build release version
      - name: Build Release Binary
        run: cargo build --release --verbose

      # Run WFL programs (Linux/macOS)
      - name: Run WFL Programs (Linux/macOS)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          #!/bin/bash
          set -e
          
          WFL_BINARY="./target/release/wfl"
          TESTPROGRAMS_DIR="./TestPrograms"
          TIMEOUT_SECONDS=30
          
          # Files to skip:
          # - Web server tests (they start servers and wait for requests)
          # - Error examples (expected to fail)
          # - Circular includes (cause infinite loops)
          # - Tests that wait for external input
          # - Helper modules (not standalone programs)
          SKIP_PATTERNS=(
            "web_server"
            "simple_web"
            "comprehensive_web"
            "error_examples"
            "circular_"
            "wait_request"
            "module_helper"
            "middleware"
            "graceful_shutdown"
            "session_test"
            "websocket"
            "respond_test"
            "test_basic_server"
            "test_static_files"
            "test_request"
            "test_cookie"
            "test_json_and_headers"
            "header_access"
            "multi_server"
            "body_limit"
            "content_length"
            "lsp_demo"
          )
          
          passed=0
          failed=0
          skipped=0
          failed_files=""
          
          echo "=== Running WFL Test Programs ==="
          echo ""
          
          # Find all .wfl files
          while IFS= read -r -d '' file; do
            filename=$(basename "$file")
            relative_path="${file#./}"
            
            # Check if file should be skipped
            skip=false
            for pattern in "${SKIP_PATTERNS[@]}"; do
              if [[ "$filename" == *"$pattern"* ]] || [[ "$relative_path" == *"error_examples"* ]]; then
                skip=true
                break
              fi
            done
            
            if [ "$skip" = true ]; then
              echo "SKIP: $relative_path"
              ((skipped++))
              continue
            fi
            
            echo -n "RUN:  $relative_path ... "
            
            # Run with timeout
            if timeout "$TIMEOUT_SECONDS" "$WFL_BINARY" "$file" > /dev/null 2>&1; then
              echo "PASS"
              ((passed++))
            else
              exit_code=$?
              if [ $exit_code -eq 124 ]; then
                echo "TIMEOUT (${TIMEOUT_SECONDS}s)"
              else
                echo "FAIL (exit code: $exit_code)"
              fi
              ((failed++))
              failed_files="$failed_files\n  - $relative_path"
            fi
          done < <(find "$TESTPROGRAMS_DIR" -name "*.wfl" -print0 | sort -z)
          
          echo ""
          echo "=== Summary ==="
          echo "Passed:  $passed"
          echo "Failed:  $failed"
          echo "Skipped: $skipped"
          echo "Total:   $((passed + failed + skipped))"
          
          if [ $failed -gt 0 ]; then
            echo ""
            echo "Failed files:$failed_files"
            exit 1
          fi

      # Run WFL programs (Windows)
      - name: Run WFL Programs (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Continue"
          
          $WflBinary = ".\target\release\wfl.exe"
          $TestProgramsDir = ".\TestPrograms"
          $TimeoutSeconds = 30
          
          # Files to skip
          $SkipPatterns = @(
            "web_server",
            "simple_web",
            "comprehensive_web",
            "error_examples",
            "circular_",
            "wait_request",
            "module_helper",
            "middleware",
            "graceful_shutdown",
            "session_test",
            "websocket",
            "respond_test",
            "test_basic_server",
            "test_static_files",
            "test_request",
            "test_cookie",
            "test_json_and_headers",
            "header_access",
            "multi_server",
            "body_limit",
            "content_length",
            "lsp_demo",
            "subprocess"  # subprocess tests use Unix commands
          )
          
          $passed = 0
          $failed = 0
          $skipped = 0
          $failedFiles = @()
          
          Write-Host "=== Running WFL Test Programs ==="
          Write-Host ""
          
          # Find all .wfl files
          $wflFiles = Get-ChildItem -Path $TestProgramsDir -Filter "*.wfl" -Recurse | Sort-Object FullName
          
          foreach ($file in $wflFiles) {
            $filename = $file.Name
            $relativePath = $file.FullName.Replace((Get-Location).Path + "\", "")
            
            # Check if file should be skipped
            $skip = $false
            foreach ($pattern in $SkipPatterns) {
              if ($filename -like "*$pattern*" -or $relativePath -like "*error_examples*") {
                $skip = $true
                break
              }
            }
            
            if ($skip) {
              Write-Host "SKIP: $relativePath"
              $skipped++
              continue
            }
            
            Write-Host -NoNewline "RUN:  $relativePath ... "
            
            # Run with timeout
            $process = Start-Process -FilePath $WflBinary -ArgumentList $file.FullName -NoNewWindow -PassThru -RedirectStandardOutput "NUL" -RedirectStandardError "NUL"
            $completed = $process.WaitForExit($TimeoutSeconds * 1000)
            
            if (-not $completed) {
              $process.Kill()
              Write-Host "TIMEOUT (${TimeoutSeconds}s)"
              $failed++
              $failedFiles += $relativePath
            } elseif ($process.ExitCode -eq 0) {
              Write-Host "PASS"
              $passed++
            } else {
              Write-Host "FAIL (exit code: $($process.ExitCode))"
              $failed++
              $failedFiles += $relativePath
            }
          }
          
          Write-Host ""
          Write-Host "=== Summary ==="
          Write-Host "Passed:  $passed"
          Write-Host "Failed:  $failed"
          Write-Host "Skipped: $skipped"
          Write-Host "Total:   $($passed + $failed + $skipped)"
          
          if ($failed -gt 0) {
            Write-Host ""
            Write-Host "Failed files:"
            foreach ($f in $failedFiles) {
              Write-Host "  - $f"
            }
            exit 1
          }

  # Version bumping only happens after ALL checks pass
  bump-version:
    name: Bump Version
    runs-on: ubuntu-latest
    needs: [fmt, clippy-and-test, integration-tests, run-wfl-programs]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: write
    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Bump version
        run: python scripts/bump_version.py --update-all

      - name: Push changes
        if: success()
        run: |
          git push origin HEAD:${{ github.ref_name }}

      - name: Tag the new version
        if: success()
        run: |
          # Fetch existing tags to avoid conflicts
          git fetch --tags

          # Extract version from version.rs
          VERSION=$(grep -oP '(?<=VERSION: &str = ")[0-9]+\.[0-9]+\.[0-9]+' src/version.rs)

          # Check if this version tag already exists
          if ! git tag -l | grep -q "^v$VERSION$"; then
            git tag -a "v$VERSION" -m "Release $VERSION"
            git push origin --tags
          else
            echo "Tag v$VERSION already exists, skipping tagging"
          fi
